<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>游戏安全-手游安全技术入门 阅读笔记 | Xman</title><meta name="author" content="Xman"><meta name="copyright" content="Xman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章静态修改文件游戏文件被静态修改并重新打包，签名 静态修改游戏资源修改游戏的资源文件，达到改变游戏逻辑或者塞入一些不健康信息的目的。 静态修改游戏代码一般手游都是用c++编写，通过编译后的游戏主逻辑的代码一般都用动态链接库保存。修改较多的是代码段和只读数据段，只读数据段的话存的一般是固定的一系列数据，一般是某些固定的参数。代码段自不用说。 修改配置和修改资源差不多，一般配置文件打包的时候都是加">
<meta property="og:type" content="article">
<meta property="og:title" content="游戏安全-手游安全技术入门 阅读笔记">
<meta property="og:url" content="https://xiananren.github.io/2023/02/20/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E6%89%8B%E6%B8%B8%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Xman">
<meta property="og:description" content="第一章静态修改文件游戏文件被静态修改并重新打包，签名 静态修改游戏资源修改游戏的资源文件，达到改变游戏逻辑或者塞入一些不健康信息的目的。 静态修改游戏代码一般手游都是用c++编写，通过编译后的游戏主逻辑的代码一般都用动态链接库保存。修改较多的是代码段和只读数据段，只读数据段的话存的一般是固定的一系列数据，一般是某些固定的参数。代码段自不用说。 修改配置和修改资源差不多，一般配置文件打包的时候都是加">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/63f38dacf144a01007224a7f.jpg">
<meta property="article:published_time" content="2023-02-20T15:27:55.203Z">
<meta property="article:modified_time" content="2023-03-06T13:53:40.141Z">
<meta property="article:author" content="Xman">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/63f38dacf144a01007224a7f.jpg"><link rel="shortcut icon" href="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230221135524334.png"><link rel="canonical" href="https://xiananren.github.io/2023/02/20/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E6%89%8B%E6%B8%B8%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '游戏安全-手游安全技术入门 阅读笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-06 21:53:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Xman" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/63f38a68f144a010071d33b2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/63f38dacf144a01007224a7f.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Xman"><span class="site-name">Xman</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">游戏安全-手游安全技术入门 阅读笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-20T15:27:55.203Z" title="发表于 2023-02-20 23:27:55">2023-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-06T13:53:40.141Z" title="更新于 2023-03-06 21:53:40">2023-03-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/">书籍阅读</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="游戏安全-手游安全技术入门 阅读笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="静态修改文件"><a href="#静态修改文件" class="headerlink" title="静态修改文件"></a>静态修改文件</h2><p>游戏文件被静态修改并重新打包，签名</p>
<h3 id="静态修改游戏资源"><a href="#静态修改游戏资源" class="headerlink" title="静态修改游戏资源"></a>静态修改游戏资源</h3><p>修改游戏的资源文件，达到改变游戏逻辑或者塞入一些不健康信息的目的。</p>
<h3 id="静态修改游戏代码"><a href="#静态修改游戏代码" class="headerlink" title="静态修改游戏代码"></a>静态修改游戏代码</h3><p>一般手游都是用c++编写，通过编译后的游戏主逻辑的代码一般都用动态链接库保存。修改较多的是代码段和只读数据段，只读数据段的话存的一般是固定的一系列数据，一般是某些固定的参数。代码段自不用说。</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>和修改资源差不多，一般配置文件打包的时候都是加密的，但是一些游戏还是不加密，这样很容易达到篡改的目的。</p>
<h2 id="动态篡改逻辑"><a href="#动态篡改逻辑" class="headerlink" title="动态篡改逻辑"></a>动态篡改逻辑</h2><p>常规的动态篡改逻辑都会伴随着注入的操作，注入就是将动态链接库加载至目标进程，让目标进程执行动态链接库的代码，实现篡改逻辑</p>
<p>android平台的注入一般分为两种，一种是通过Zygote进程（xposed）渗透到目标进程之中，另一种是直接注入到目标进程之中。</p>
<p>IOS平台一般用MobileSubStrate组件将动态链接库注入游戏进程。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>安卓可以通过”&#x2F;proc&#x2F;&lt;pid&gt;&#x2F;maps”文件遍历有r标识的模块，然后读写”&#x2F;proc&#x2F;&lt;pid&gt;&#x2F;mem”文件达到和注入式修改差不多的效果</p>
<h2 id="游戏协议"><a href="#游戏协议" class="headerlink" title="游戏协议"></a>游戏协议</h2><p>游戏协议修改可以有两种因素，重发游戏协议或者篡改游戏协议。一般通过给发至客户端的游戏协议加密或者哈希校验来解决篡改游戏协议的问题，通过给协议加序号字段的方式防止对方重发游戏协议。</p>
<p><strong>服务器不能轻易相信客户端传来的数据，才能保护游戏的安全性</strong></p>
<h3 id="重发游戏协议"><a href="#重发游戏协议" class="headerlink" title="重发游戏协议"></a>重发游戏协议</h3><p>一般这种危害造成的原因不是游戏开发对协议的逻辑检测有问题，而是协议字段少，协议之间耦合性不好。要是每个协议加上时间等字段，就不至于会被轻易的复制粘贴而攻破。</p>
<h1 id="第二章-外挂的定义，分类和实现原理"><a href="#第二章-外挂的定义，分类和实现原理" class="headerlink" title="第二章 外挂的定义，分类和实现原理"></a>第二章 外挂的定义，分类和实现原理</h1><h2 id="外挂分类"><a href="#外挂分类" class="headerlink" title="外挂分类"></a>外挂分类</h2><h3 id="辅助版外挂"><a href="#辅助版外挂" class="headerlink" title="辅助版外挂"></a>辅助版外挂</h3><h4 id="内存修改器"><a href="#内存修改器" class="headerlink" title="内存修改器"></a>内存修改器</h4><p>修改内存，和cheat engine差不多</p>
<h4 id="变速器"><a href="#变速器" class="headerlink" title="变速器"></a>变速器</h4><p>加快或减慢游戏速度。</p>
<h4 id="按键精灵"><a href="#按键精灵" class="headerlink" title="按键精灵"></a>按键精灵</h4><p>记录手机的按键，实现自动化刷金币等操作。</p>
<h4 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h4><p>用电脑模拟，打枪啊格斗啊都比手机好用很多。</p>
<h4 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h4><p>主要是作用于协议没加密的那种类型。抓到协议的包，然后篡改或者重发实现外挂功能</p>
<h3 id="破解版外挂"><a href="#破解版外挂" class="headerlink" title="破解版外挂"></a>破解版外挂</h3><p>本质上是一个非法客户端。可分为脱机挂和修改原客户端两类。</p>
<p>脱机挂是外挂作者基于对协议的分析，自行开发的一个非法客户端。工作室对这个需求巨大</p>
<h3 id="辅助版外挂实现原理"><a href="#辅助版外挂实现原理" class="headerlink" title="辅助版外挂实现原理"></a>辅助版外挂实现原理</h3><h4 id="专用插件"><a href="#专用插件" class="headerlink" title="专用插件"></a>专用插件</h4><p>定制外挂，每个外挂对应一个游戏。用注入的技术将功能模块注入内存之中，并执行功能模块的入口函数。</p>
<p>android一般是Zygote注入或者ptrace注入，ios一般是利用Cydia框架注入dylib模块。</p>
<p>外挂模块被注入内存后会通过hook的方式去hook一些游戏的相关函数，实现外挂的功能。这个需要外挂人员提前逆向分析得到对应操作的代码位置和逻辑，然后通过功能模块hook这些函数，来改变参数或者进行其他操作。</p>
<h4 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h4><h5 id="内存修改器-1"><a href="#内存修改器-1" class="headerlink" title="内存修改器"></a>内存修改器</h5><p>实现方式有两种：一类实现和专用插件类似，外挂的功能模块注入游戏进程中然后用本地的Socket接收操作，直接遍历内存的方式实现。</p>
<p>另一类就是利用平台加载机制取巧实现。例如在Android平台下通过&#x2F;proc&#x2F;[pid]&#x2F;maps可读写游戏的内存镜像。</p>
<h5 id="变速器-1"><a href="#变速器-1" class="headerlink" title="变速器"></a>变速器</h5><p>影响了游戏的时间度量，游戏一般是以帧为时间计量单位，通过调用c函数来计算每帧的更新。加速器一般就是hook libc.so文件中的关于时间的函数，比如gettimeofday，clock_gettime。修改方式就是上面的hook实现。针对libc的导出函数可以利用导入表hook的方式。</p>
<h5 id="按键精灵-1"><a href="#按键精灵-1" class="headerlink" title="按键精灵"></a>按键精灵</h5><p>调用系统api来发送按键序列，一般和系统息息相关.Android可通过Instrumentation接口的sendPointerSync函数实现，也可以通过有root权限的驱动程序去调用Runtime.getRuntime().exec()去执行sendevent等命令</p>
<h5 id="模拟器-1"><a href="#模拟器-1" class="headerlink" title="模拟器"></a>模拟器</h5><p>主要实现逻辑就是用VirtualBox模拟Android系统，可直接模拟x86的Android系统。</p>
<h5 id="抓包工具-1"><a href="#抓包工具-1" class="headerlink" title="抓包工具"></a>抓包工具</h5><p>本质是一个网络数据包编辑器，一类实现是用硬件的方法，让网卡变成混乱模式，即可拦截数据包，另一类实现是hook recv，send等函数，获得数据包。</p>
<h3 id="破解版外挂实现原理"><a href="#破解版外挂实现原理" class="headerlink" title="破解版外挂实现原理"></a>破解版外挂实现原理</h3><p>破解版外挂是预先静态修改过的第三方游戏客户端。脱机挂是外挂作者在逆向分析协议后编写的第三方客户端，对技术要求大，因为要完全分析协议。</p>
<p>另一类是对游戏客户端进行静态修改的破解版，分为修改逻辑代码和数据两种</p>
<h4 id="逻辑代码"><a href="#逻辑代码" class="headerlink" title="逻辑代码"></a>逻辑代码</h4><p>Android下的逻辑代码修改，不同游戏引擎方法也不同。</p>
<p>Cocos2D游戏，逻辑代码保存在so文件之中，一般用ida分析</p>
<p>C#保存在Assembly-CSharp.dll中。</p>
<p>ios的文件就直接分析bin文件即可。</p>
<p>改动的话一般是改跳转或者改参数。</p>
<h4 id="数据资源"><a href="#数据资源" class="headerlink" title="数据资源"></a>数据资源</h4><p>包括除源代码以外的所有资源，包括图片资源，配置资源，音乐资源等。方式一般有两种，无脑替换和分析调试</p>
<p>无脑替换就是直接一个个删除，看游戏的变化。比如有些游戏安全性不够，就会被如此打击。比如射击游戏删除子弹资源，跑酷游戏覆盖关卡信息等。</p>
<p>分析调试就是通过逆向分析的方式去识别加密并解密，得到逻辑后再替换或patch</p>
<h1 id="第三章-手游外挂技术汇总"><a href="#第三章-手游外挂技术汇总" class="headerlink" title="第三章 手游外挂技术汇总"></a>第三章 手游外挂技术汇总</h1><h2 id="arm汇编"><a href="#arm汇编" class="headerlink" title="arm汇编"></a>arm汇编</h2><p>所有ios和绝大多数Android都是用ARM架构的CPU，做游戏安全分析很多时候要修改汇编代码，所以学习arm汇编是很必要的。</p>
<h2 id="c-x2F-c"><a href="#c-x2F-c" class="headerlink" title="c&#x2F;c++"></a>c&#x2F;c++</h2><p>虽然Android平台主要用java编写应用,IOS平台主要用Objective-C来编写，但是考虑到游戏的跨平台性和执行效率，一般主要还是考虑用c或c++，用OpenGL ES来绘制界面。而cocos2d-x可以用多种语言编写游戏逻辑，不过为了效率大部分还是用c++，且大部分外挂都是c++编写。</p>
<h2 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h2><p>绝大部分逻辑代码在native层实现，所以Android开发的最低要求是会Android程序的生命周期和native程序的开发。</p>
<h2 id="IOS开发"><a href="#IOS开发" class="headerlink" title="IOS开发"></a>IOS开发</h2><p>和Android差不多，要了解IOS的生命周期和Xcode，Objective-C。</p>
<h2 id="常用的游戏引擎"><a href="#常用的游戏引擎" class="headerlink" title="常用的游戏引擎"></a>常用的游戏引擎</h2><p>unity3D用c#开发，Cocos2d-x用c++或lua</p>
<h2 id="静态修改"><a href="#静态修改" class="headerlink" title="静态修改"></a>静态修改</h2><p>对于java代码，一般用apktools反编译后直接修改smali代码，然后重打包和签名</p>
<p>c#一般是修改IL指令然后编译成dll文件替换原来的。</p>
<h1 id="第七章-手游开发基础"><a href="#第七章-手游开发基础" class="headerlink" title="第七章 手游开发基础"></a>第七章 手游开发基础</h1><h2 id="游戏玩法与分类"><a href="#游戏玩法与分类" class="headerlink" title="游戏玩法与分类"></a>游戏玩法与分类</h2><h3 id="MMORPG"><a href="#MMORPG" class="headerlink" title="MMORPG"></a>MMORPG</h3><p>和魔兽世界差不多，意思是大型多人在线角色扮演游戏。服务器一直延续，打怪的时候别人能参与，不会进入一个特定的地方单独进行。优点是实现了一个世界，很自由。缺点是不爽，打击感不强，因为首先这是强服务器游戏，要保证服务器的正常运作，所以每个人特效不会很离谱，而且一般是服务器端判断你的击中或者伤害或者什么再下发给你，所以会有网络延迟问题，没实时的那么爽。但是安全性会很高。</p>
<h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><p>第一人称射击游戏，特别注重实时性，所以不可避免的要把逻辑放在本地。所以挂多，嗯</p>
<h3 id="ARPG"><a href="#ARPG" class="headerlink" title="ARPG"></a>ARPG</h3><p>动作角色扮演游戏，相比MMORPG更加注重实时性，所以本地也有很多逻辑</p>
<h2 id="手游开发语言"><a href="#手游开发语言" class="headerlink" title="手游开发语言"></a>手游开发语言</h2><p>手机游戏开发分为服务端开发和客户端开发</p>
<p>服务端开发一般都是用c&#x2F;c++,不过java和python也有。但是对于MMO这种对服务器实时性要求高的游戏，就必须用c++</p>
<p>客户端开发一般都是用公开的引擎，unity3D，Cocos2d-x等。而这些引擎都有固定的使用语言，所以其实安全性在定下用什么引擎的时候就已经大致定下来了，和语言没关系</p>
<h2 id="手游网络模式"><a href="#手游网络模式" class="headerlink" title="手游网络模式"></a>手游网络模式</h2><p>一般分为两种，强联网和弱联网模式</p>
<p>强联网对应的一般是FPS等对于实时性要求很高的游戏，这个是不能断网的。</p>
<p>弱联网就像天天酷跑等游戏，中间断网没事，只要结算的时候有网就行。</p>
<p>优点和缺点很容易看出，强联网逻辑大部分在服务器，安全性高，弱联网本地多，所以安全性差</p>
<h1 id="第八章-游戏引擎的基本概念和常见介绍"><a href="#第八章-游戏引擎的基本概念和常见介绍" class="headerlink" title="第八章 游戏引擎的基本概念和常见介绍"></a>第八章 游戏引擎的基本概念和常见介绍</h1><h2 id="游戏引擎是什么"><a href="#游戏引擎是什么" class="headerlink" title="游戏引擎是什么"></a>游戏引擎是什么</h2><p>游戏的核心部件的功能代码</p>
<p>游戏的运行实现可以分为4层，从下往上依次是硬件层，第三方组件层，引擎层，游戏逻辑层</p>
<h2 id="游戏引擎子系统"><a href="#游戏引擎子系统" class="headerlink" title="游戏引擎子系统"></a>游戏引擎子系统</h2><h3 id="渲染系统"><a href="#渲染系统" class="headerlink" title="渲染系统"></a>渲染系统</h3><p>是引擎所有子系统中最复杂最强大的一块。渲染可以看成把二进制文件变成图像输出到屏幕的一个过程</p>
<p>游戏引擎的渲染系统一般是用图像API完成的，例如d3d，OpenGL等。</p>
<h3 id="音频系统"><a href="#音频系统" class="headerlink" title="音频系统"></a>音频系统</h3><p>有类似渲染系统的API：Windows Multimedia,OpenAL等。</p>
<h3 id="物理系统"><a href="#物理系统" class="headerlink" title="物理系统"></a>物理系统</h3><p>游戏中比较常用的场景是碰撞检测，因为接口是公开的，写外挂的人很容易可以定位对应代码并且修改。会实现穿墙或者无敌等功能。</p>
<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><h1 id="第九章-游戏漏洞简述"><a href="#第九章-游戏漏洞简述" class="headerlink" title="第九章 游戏漏洞简述"></a>第九章 游戏漏洞简述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="游戏逻辑漏洞"><a href="#游戏逻辑漏洞" class="headerlink" title="游戏逻辑漏洞"></a>游戏逻辑漏洞</h3><p>通过修改客户端的游戏来实现外挂功能。和游戏开发时的网络架构有关，不是所有游戏都有，在游戏客户端实现。</p>
<p>游戏逻辑漏洞和网络协议关系密切，如果强联网游戏漏洞较少，反之较多。所以要找游戏逻辑漏洞要先看网络类型。</p>
<h3 id="游戏协议稳定性漏洞"><a href="#游戏协议稳定性漏洞" class="headerlink" title="游戏协议稳定性漏洞"></a>游戏协议稳定性漏洞</h3><p>指构造畸形协议使协议处理方因无法处理协议而崩溃的漏洞。和服务器类型和网络架构没关系，所有游戏都可能出现。挖掘漏洞的过程实际上就是畸形协议的构造过程，一般用fuzz的思想去挖掘畸形协议字段</p>
<h3 id="游戏服务端校验疏忽型漏洞"><a href="#游戏服务端校验疏忽型漏洞" class="headerlink" title="游戏服务端校验疏忽型漏洞"></a>游戏服务端校验疏忽型漏洞</h3><p>就和篡改协议那种差不多，主要是服务端校验不严，依赖于开发人员的严谨性。比如协议耦合性不好，字段少等。</p>
<h1 id="第十章-静态分析"><a href="#第十章-静态分析" class="headerlink" title="第十章 静态分析"></a>第十章 静态分析</h1><h2 id="arm速成"><a href="#arm速成" class="headerlink" title="arm速成"></a>arm速成</h2><h3 id="体系简介"><a href="#体系简介" class="headerlink" title="体系简介"></a>体系简介</h3><p>有15个通用寄存器，r13是sp，r14是LR，保存的是函数的返回地址，r15是pc，指向当前指令地址+8处。</p>
<h3 id="指令样例"><a href="#指令样例" class="headerlink" title="指令样例"></a>指令样例</h3><h4 id="B-x2F-BL指令"><a href="#B-x2F-BL指令" class="headerlink" title="B&#x2F;BL指令"></a>B&#x2F;BL指令</h4><p>作用是跳到某个地址。</p>
<h5 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h5><p>二进制解释的话，0到23位是offset，是目标地址和当前指令的相对偏移，要左移两位，因为偏移是4字节对齐的。</p>
<h5 id="L"><a href="#L" class="headerlink" title="L"></a>L</h5><p>24位为L，L位为一的话代表存储下一位的地址到LR寄存器中。</p>
<h5 id="标识码"><a href="#标识码" class="headerlink" title="标识码"></a>标识码</h5><p>25到27位是标识码，代表当前的指令是什么</p>
<h5 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h5><p>28到31位是cond位。代表指令的条件，标识码101对应的是B指令，然后cond如果为0000代表是BEQ指令</p>
<h4 id="LDR-x2F-STR"><a href="#LDR-x2F-STR" class="headerlink" title="LDR&#x2F;STR"></a>LDR&#x2F;STR</h4><p>假设一个指令如下</p>
<p>LDR   R2,  [R12]</p>
<p>二进制含义如下</p>
<p>1110   			01 			011001			1100			0010				0000 0000 0000</p>
<p>Cond			   op      	  IPUBWL			Rn				Rd					Offset</p>
<h5 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h5><p>表示啥都行</p>
<h5 id="op"><a href="#op" class="headerlink" title="op"></a>op</h5><p>标识码</p>
<h5 id="I"><a href="#I" class="headerlink" title="I"></a>I</h5><p>I是0代表offset是立即数</p>
<h5 id="B"><a href="#B" class="headerlink" title="B"></a>B</h5><p>B是0代表传输的是一个字</p>
<h5 id="L-1"><a href="#L-1" class="headerlink" title="L"></a>L</h5><p>L是1代表读内存</p>
<h5 id="Rn"><a href="#Rn" class="headerlink" title="Rn"></a>Rn</h5><p>0xc，代表基址寄存器是R12</p>
<h5 id="Rd"><a href="#Rd" class="headerlink" title="Rd"></a>Rd</h5><p>是2，表示把内存值读到R2</p>
<h5 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h5><p>和上面一样</p>
<p>实际的指令含义为：读取R12寄存器指向的内存的值到R2寄存器中，读取4个字节。</p>
<h3 id="Thumb指令简述"><a href="#Thumb指令简述" class="headerlink" title="Thumb指令简述"></a>Thumb指令简述</h3><p>看CPSR寄存器的第6个bit是否为1，如果是1就是Thumb，否则arm</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>比较常见的是把前四个参数放到R0~3中，然后剩下的放到栈里面。返回值放到r0之中。</p>
<h1 id="第十一章-动态调试"><a href="#第十一章-动态调试" class="headerlink" title="第十一章 动态调试"></a>第十一章 动态调试</h1><h2 id="加载安卓原生动态链接库"><a href="#加载安卓原生动态链接库" class="headerlink" title="加载安卓原生动态链接库"></a>加载安卓原生动态链接库</h2><p>远程附加调试的时候，如果用户相对init_array段或JNI_Onload进行动态调试，则用attach的方法是不行的，因为他们已经执行了。</p>
<h3 id="调试JNI-Onload和init-array"><a href="#调试JNI-Onload和init-array" class="headerlink" title="调试JNI_Onload和init_array"></a>调试JNI_Onload和init_array</h3><p>普通的附加是不行的，我们得用am来用调试模式打开程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">am start -D -n com.example.xxx/.MainActivity</span><br></pre></td></tr></table></figure>

<p>然后使用ida附加到被调试进程，不过调试选项还得勾选Suspend on library load&#x2F;unload</p>
<p>在ida附加到程序后，还需要用jdb命令来让程序恢复执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</span><br></pre></td></tr></table></figure>

<h1 id="第十三章-注入技术的实现原理"><a href="#第十三章-注入技术的实现原理" class="headerlink" title="第十三章 注入技术的实现原理"></a>第十三章 注入技术的实现原理</h1><h2 id="Android下ptrace注入技术的实现"><a href="#Android下ptrace注入技术的实现" class="headerlink" title="Android下ptrace注入技术的实现"></a>Android下ptrace注入技术的实现</h2><h3 id="ptrace函数介绍"><a href="#ptrace函数介绍" class="headerlink" title="ptrace函数介绍"></a>ptrace函数介绍</h3><p>ptrace原型如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long ptrace(enum __ptrace_request request,pid_t pid,void *addr,void *data);</span><br></pre></td></tr></table></figure>

<h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><p>request参数是一个union，该参数决定了ptrace的行为</p>
<p>不同的request含义不一样。</p>
<p>request含义比较多，挑几个重要的参数信息及解释如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_ATTACH		附加到指定远程进程</span><br><span class="line">PTRACE_DETACH		从指定远程进程中分离</span><br><span class="line">PTRACE_GETREGS		读取远程进程当前的寄存器环境</span><br><span class="line">PTRACE_SETREGS		设置远程进程的寄存器环境</span><br><span class="line">PTRACE_CONT			使远程进程继续运行</span><br><span class="line">PTRACE_PEEKTEXT		从远程进程指定地址读取一个word大小的数据</span><br><span class="line">PTRACE_POKETEXT		往远程进程指定内存地址出写入一个word大小的数据</span><br></pre></td></tr></table></figure>

<h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h4><p>是远程进程的id</p>
<h4 id="addr-x2F-data"><a href="#addr-x2F-data" class="headerlink" title="addr&#x2F;data"></a>addr&#x2F;data</h4><h3 id="ptrace注入进程流程"><a href="#ptrace注入进程流程" class="headerlink" title="ptrace注入进程流程"></a>ptrace注入进程流程</h3><p>ptrace注入的目的是将将外部的模块注入到对应的游戏进程之中，然后执行模块相应的代码。一般有两种方法</p>
<ul>
<li>ptrace将shellcode注入到远程进程的内存空间中，然后去执行该代码。</li>
<li>远程调用dlopen，dlsym模块去加载被注入的模块并执行对应的代码。</li>
</ul>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><ol>
<li>attach到远程进程</li>
<li>保存寄存器环境</li>
<li>利用mmap函数分配内存</li>
<li>向远程的内存空间写入模块名和注入函数</li>
<li>用dlopen去打开注入函数</li>
<li>用dlsym去获得注入函数的地址</li>
<li>调用该函数</li>
<li>恢复寄存器环境</li>
<li>detach</li>
</ol>
<h3 id="ptrace注入的实现"><a href="#ptrace注入的实现" class="headerlink" title="ptrace注入的实现"></a>ptrace注入的实现</h3><h4 id="附加到远程进程"><a href="#附加到远程进程" class="headerlink" title="附加到远程进程"></a>附加到远程进程</h4><p>用ptrace，第一个参数设置为attach，addr和data参数都为null</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ptrace</span>(PTRACE_ATTACH,pid,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>附加到远程进程后，远程进程执行会中断。父进程可以调用waitpid函数查看子进程是否处于暂停状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pid_t waitpid(pid_t pid,int * status,int options)</span><br></pre></td></tr></table></figure>

<p>其中要是option参数为WUNTRACED的话，表示如果pid对应的进程是处于暂停状态，立马返回。通过这个函数等待子进程执行到暂停。</p>
<h4 id="读取和写入寄存器值"><a href="#读取和写入寄存器值" class="headerlink" title="读取和写入寄存器值"></a>读取和写入寄存器值</h4><p>在通过ptrace改变对应进程的状态之前，需要先读取和保存对应进程的所有寄存器状态。detach的时候将保存好的寄存器值写入回目标进程，不保存的话目标进程恢复执行的时候会崩溃</p>
<p>实现的话，用ptrace的request中的setreg和getreg即可实现。对应调用代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ptrace</span>(PTRACE_GETREGS,pid,<span class="literal">NULL</span>,regs);</span><br><span class="line"><span class="built_in">ptrace</span>(PTRACE_SETREGS,pid,<span class="literal">NULL</span>,regs);</span><br></pre></td></tr></table></figure>

<p>在ARM处理器下，ptrace函数中data参数的regs是pt_regs结构的指针，从远程进程获取的寄存器值将存储到该结构中。pt_regs结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pt_regs</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> uregs[<span class="number">18</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_cpsr uregs[16]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_pc uregs[15]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_lr uregs[14]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_sp uregs[13]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_ip uregs[12]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_fp uregs[11]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r10 uregs[10]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r9 uregs[9]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r8 uregs[8]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r7 uregs[7]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r6 uregs[6]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r5 uregs[5]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r4 uregs[4]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r3 uregs[3]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r2 uregs[2]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r1 uregs[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_r0 uregs[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARM_ORIG_r0 uregs[17]</span></span><br></pre></td></tr></table></figure>

<h4 id="远程进程的内存读取和写入数据"><a href="#远程进程的内存读取和写入数据" class="headerlink" title="远程进程的内存读取和写入数据"></a>远程进程的内存读取和写入数据</h4><p>request参数为PTRACE_PEEKTEXT时，可以从对应的远程进程的内存中读入一个word回来。</p>
<p>调用实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ptrace</span>(PTRACE_PEEKTEXT,pid,pCurSrcBuf,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">ptrace</span>(PTRACE_POKETEXT,pid,pCurDestBuf,ITmpBuf);</span><br></pre></td></tr></table></figure>

<p>addr参数为需要读取的远程内存的地址，返回值为读取的数据。</p>
<p>POKETEXT是写入远程的内存，也是一次一个word</p>
<p>写入数据时要注意，如果写入的数据长度不是word的倍数，则在写入最后一个不是word的数据时，要保存高位地址的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ITmpBuf = <span class="built_in">ptrace</span>(PTRACE_PEEKTEXT,pid,pCurDestBuf,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)(&amp;ITmpBuf),pCurSrcBuf,nRemainCount);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">ptrace</span>(PTRACE_POKETEXT,pid,pCurDstBuf,ITmpBuf) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="远程调用函数"><a href="#远程调用函数" class="headerlink" title="远程调用函数"></a>远程调用函数</h4><p>arm处理器的函数调用的前4个参数是由r0~r3传递。剩余的参数按由右向左的顺序压入栈中进行传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_params &amp;&amp; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    regs-&gt;uregs[i] = parameters[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;num_params)&#123;</span><br><span class="line">    regs-&gt;ARM_sp -= (num_params-i)*<span class="built_in">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ptrace_writedata</span>(pid,(<span class="type">void</span>*)regs-&gt;ARM_sp,(<span class="type">uint8_t</span>*)&amp;parameters[i],(num_params-i)*<span class="built_in">sizeof</span>(<span class="type">long</span>))==<span class="number">-1</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>远程调用函数前要先检查一下调用参数的个数，如果多于四个就先调整sp寄存器在栈中分配的空间大小，再通过ptrace将剩下的参数写入栈中。</p>
<p>写入函数参数后，将pc改为要执行函数的地址。因为arm架构下有arm和thumb两种指令，所以要先看看是哪种。</p>
<p>可以通过地址最低位是否为1判断调用地址指令是哪个。</p>
<p>如果是thumb，要把最低位设置为0，并将CPSR的T标志位置位。如果是arm，就把CPSR的标志位复位</p>
<p>远程进程恢复运行前，要设置远程进程的LR寄存器为0，并在本地调用waitpid函数。</p>
<p>远程进程的函数调用结束后，会跳到LR对应的寄存器之中，而LR设置为0，所以会报错并停止程序，随后waitpid返回并接管子进程。通过读取远程进程的r0可以知道函数返回结果。</p>
<p>ptrace 要调用很多函数，比如mmap，dlopen等。</p>
<p>mmap函数位置在&#x2F;system&#x2F;lib&#x2F;libc.so模块，dlopen,dlsym,dlclose都在&#x2F;system&#x2F;bin&#x2F;linker模块中</p>
<p>读取&#x2F;proc&#x2F;pid&#x2F;maps可以得到系统模块在本地进程和远程进程的加载的基地址，要获取远程进程的mmap等函数的地址，可以通过计算本地进程的mmap和模块的偏移，然后看看远程进程的模块基址，加上偏移就是对应的函数</p>
<h4 id="恢复寄存器值"><a href="#恢复寄存器值" class="headerlink" title="恢复寄存器值"></a>恢复寄存器值</h4><p>不恢复就奔溃</p>
<h4 id="detach进程"><a href="#detach进程" class="headerlink" title="detach进程"></a>detach进程</h4><p>用ptrace的PTRACE_DETACH即可。</p>
<h2 id="Android下Zygote注入技术的实现"><a href="#Android下Zygote注入技术的实现" class="headerlink" title="Android下Zygote注入技术的实现"></a>Android下Zygote注入技术的实现</h2><p>Zygote是Android操作系统的孵化器进程</p>
<h3 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h3><p>绝大部分的游戏进程都是由Zygote fork出来的，而我们知道fork出来的子进程和父进程的模块是完全一样，所以如果我们能在Zygote中注入恶意进程，他fork出来的进程也会有</p>
<h3 id="注入实现流程"><a href="#注入实现流程" class="headerlink" title="注入实现流程"></a>注入实现流程</h3><ul>
<li>注入器注入模块a到Zygote进程</li>
<li>手动fork出进程b</li>
<li>模块a夺取进程b的控制权</li>
<li>执行模块a的代码</li>
<li>归还控制权给进程b</li>
</ul>
<p>此处注意两个点</p>
<ul>
<li>目标进程需要在注入Zygote后启动才能被注入</li>
<li>成功注入Zygote之后所有生成的新进程都会有已注入Zygote的模块信息，需要在新启动的进程执行之前获得执行权，然后判断当前进程是否为目标进程，如果是，执行相关代码，否则返回执行权</li>
</ul>
<h3 id="注入器的实现方式"><a href="#注入器的实现方式" class="headerlink" title="注入器的实现方式"></a>注入器的实现方式</h3><p>是整个流程的开始，也是最重要的一环。目的是将模块注入到Zygote进程之中。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221106132655666.png" alt="image-20221106132655666"></p>
<p>注入器一共实现了三次跨进程调用</p>
<ol>
<li>调用mmap申请对应的进程地址空间，保存我们的shellcode</li>
<li>远程执行shellcode</li>
<li>munmap释放之前的内存</li>
</ol>
<p>shellcode实现的功能为：将指定的模块加载到目标进程之中，然后执行模块的入口代码</p>
<h3 id="注入器各功能实现"><a href="#注入器各功能实现" class="headerlink" title="注入器各功能实现"></a>注入器各功能实现</h3><h4 id="关闭SeLinux"><a href="#关闭SeLinux" class="headerlink" title="关闭SeLinux"></a>关闭SeLinux</h4><p>Selinux是linux的一个安全子系统，在Android4.4后的版本默认打开此功能，Selinux会影响注入的实现，所以要事先关闭此功能。</p>
<p>关闭有三个操作</p>
<ul>
<li>获取SeLinux的配置目录。可以通过查看&#x2F;sys&#x2F;fs&#x2F;selinux目录的文件系统状态，如果等于SELINUX_MAGIC的话就是SeLinux的配置目录。另一种是通过&#x2F;proc&#x2F;mounts文件查看是否存在SeLinux的路径</li>
<li>获取配置文件的SeLinux的开关状态</li>
<li>关闭SeLinux</li>
</ul>
<h4 id="附加到Zygote，保存进程现场"><a href="#附加到Zygote，保存进程现场" class="headerlink" title="附加到Zygote，保存进程现场"></a>附加到Zygote，保存进程现场</h4><p>Android系统中进程同步的信号机制和Linux相似。</p>
<p>当注入器附加到Zygote上后，Zygote会接到一个SIGSTOP信号，然后他处理这个信号，这时父进程用waitPid函数进行等待，等待子进程也就是Zygote进程进行操作，结束后才返回。</p>
<p>waitpid很多作用，一般的作用是阻塞当前进程，等待指定进程状态发生变化。</p>
<p>第三个参数为0的时候，使用默认的阻塞式等待，知道Zygote处理完SIGSTOP信息。Zygote停止时，进程状态发生变化，waitpid返回Zygote的进程状态，注入器被唤醒。</p>
<p>下方为WaitPid的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WaitPid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> option)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">waitpid</span>(pid,status,option) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(error == EINTR)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果注入器收到的是让waitpid中断的信号就不管，否则就直接返回。</p>
<h4 id="获取Zygote进程关键函数的地址"><a href="#获取Zygote进程关键函数的地址" class="headerlink" title="获取Zygote进程关键函数的地址"></a>获取Zygote进程关键函数的地址</h4><p>和pwn差不多，首先在注入器加载libc.so，然后获得注入器的函数地址，相减求得偏移。随后在Zygote里找到libc.so的基址然后加上这个偏移即可。</p>
<h4 id="调用mmap函数"><a href="#调用mmap函数" class="headerlink" title="调用mmap函数"></a>调用mmap函数</h4><p>mmap的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span></span><br></pre></td></tr></table></figure>

<p>根据arm编译器的规则，要把前四个参数放r0到r3中，然后其余参数放到堆栈中。所以我们要调用mmap，要布置一下堆栈。</p>
<p>解决堆栈布局的思路是，将pc设置为mmap的首地址，同时LR设置为0.给Zygote发送PTRACE_CONT信号，让Zygote从mmap的首地址开始执行，执行结束后跳到LR对应的地址，也就是0，然后出现异常停止，waitpid返回，回到父进程继续执行。</p>
<h4 id="配置shellcode"><a href="#配置shellcode" class="headerlink" title="配置shellcode"></a>配置shellcode</h4><p>shellcode代码主要做了三个事</p>
<ul>
<li>用dlopen加载指定模块</li>
<li>用dlsym加载指定模块的地址</li>
<li>调用指定模块</li>
</ul>
<p>最后同样设置ir为0，让父进程接管之后的操作。</p>
<h4 id="远程调用shellcode"><a href="#远程调用shellcode" class="headerlink" title="远程调用shellcode"></a>远程调用shellcode</h4><p>和调用mmap差不多，只是mmap将ir赋值为0是在调用之前的操作，而shellcode是在shellcode执行的过程中将其赋值为0</p>
<h4 id="调用munmap释放内存"><a href="#调用munmap释放内存" class="headerlink" title="调用munmap释放内存"></a>调用munmap释放内存</h4><h4 id="恢复进程到初始状态"><a href="#恢复进程到初始状态" class="headerlink" title="恢复进程到初始状态"></a>恢复进程到初始状态</h4><p>将寄存器和堆栈还原后，直接detach</p>
<h3 id="注入Zygote模块的功能"><a href="#注入Zygote模块的功能" class="headerlink" title="注入Zygote模块的功能"></a>注入Zygote模块的功能</h3><p>除了特定的一系列功能外，模块基本上都有这两个功能</p>
<ul>
<li>劫持新启动的进程并获得控制权，hook Zygote的一些系统函数来感知新进程的创造</li>
<li>查看当前进程是否是目标进程</li>
</ul>
<h2 id="Android感染elf文件的注入技术实现"><a href="#Android感染elf文件的注入技术实现" class="headerlink" title="Android感染elf文件的注入技术实现"></a>Android感染elf文件的注入技术实现</h2><p>可执行文件感染意思是，通过修改可执行文件的二进制文件，让该可执行文件在执行的时候先执行我们写入的代码再执行原逻辑</p>
<h3 id="感染elf文件实现原理"><a href="#感染elf文件实现原理" class="headerlink" title="感染elf文件实现原理"></a>感染elf文件实现原理</h3><p>通过修改Program Header Table中的依赖库信息，添加自定义的库文件，当游戏进程加载主逻辑模块的时候，也加载了我们所写的库文件</p>
<p>Program Header Table的表项结构如下</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221106184045441.png" alt="image-20221106184045441"></p>
<p>其中p_type的取值定义如下</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221106184144895.png" alt="image-20221106184144895"></p>
<p>当p_type取值为PT_LOAD时，描述程序加载时的内存映射信息</p>
<p>当p_type取值为PT_DYNAMIC时，p_offset（偏移）和p_filesz（大小）会指向dynamic段。dynamic段描述的是链接和加载时的库信息，是一个结构体数组。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221106184417221.png" alt="image-20221106184417221"></p>
<p>需要关注的是d_tag的四种取值情况</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221106184534299.png" alt="image-20221106184534299"></p>
<h3 id="感染elf文件的注入实现过程"><a href="#感染elf文件的注入实现过程" class="headerlink" title="感染elf文件的注入实现过程"></a>感染elf文件的注入实现过程</h3><ul>
<li>在DT_STRTAB指向的字符串表中加入一个新的元素，就是我们的so模块的名称，由于凭空添加一项，插在中间的话后面的所有元素偏移都将改变，所以一般将字符串表移至文件末尾。</li>
<li>由于字符串表会被映射到内存之中，所以我们得在Program Header Table处添加一个PT_LOAD表项，指向我们的船新字符串表，同时将Program Header Table添加到文件末尾。</li>
<li>修改DT_STRTAB,DT_STRSZ，指向新的字符串表，同时在dynamic array的结尾加上DT_NEEDED，指向我们的so模块</li>
<li>修改ELF Header的Program Header Table信息，指向我们的船新表</li>
</ul>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221106190247989.png" alt="image-20221106190247989"></p>
<h3 id="感染elf文件的实例分析"><a href="#感染elf文件的实例分析" class="headerlink" title="感染elf文件的实例分析"></a>感染elf文件的实例分析</h3><p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221106190627481.png" alt="image-20221106190627481"></p>
<p>重要信息如下</p>
<ul>
<li>elfheader.e_phoff, elfheader.e_phentsize ,elfheader.e_phnum分别保存了program header table的位置，大小和表项个数信息</li>
<li>program_header_table.program_table_element[0]保存了program_header_table的位置和内存映射的信息</li>
<li>program_header_table.program_table_element[1]将文件相对偏移0到2238752的数据映射到了内存之中</li>
<li>program_header_table.program_table_element[3]保存了dynamic array结构数组的起始位置和大小信息</li>
</ul>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>看D:\书籍\游戏安全手游安全技术入门\代码\elfinfector\jni\elfinfector.c</p>
<p>它会告诉你一切</p>
<h1 id="第十四章-hook技术的实现原理"><a href="#第十四章-hook技术的实现原理" class="headerlink" title="第十四章 hook技术的实现原理"></a>第十四章 hook技术的实现原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hook技术的目的是，在目标模块执行之前，监视寄存器和数据，改变模块功能</p>
<h2 id="基于异常的hook实现"><a href="#基于异常的hook实现" class="headerlink" title="基于异常的hook实现"></a>基于异常的hook实现</h2><p>用SIGILL异常机制可以实现hook操作。对想要监控的地址设置一个非法指令，当执行到此指令时触发异常，调用事先设定好的异常回调函数，恢复监控地址的原指令，打印寄存器，获得上下文。不过这样只能一次hook，下次再执行到该地址的时候就不会再触发异常了。于是我们可以通过在要触发异常的地址的下一个地址处设置一个非法指令，判断当前的指令和下一个指令是否为非法指令，如果是的话证明是我们要处理的那个指令，如果不是的话证明是我们的恢复指令，再把对应的地址的指令设置为非法指令，从而在下一次运行到该指令的时候再次触发。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221108185510732.png" alt="image-20221108185510732"></p>
<p>系统通过sigaction API注册SIGILL信号的异常处理回调函数</p>
<p>arm之间的地址差值为4，Thumb2指令集的画有2有4，所以需要解析当前指令的长度</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221108185743767.png" alt="image-20221108185743767"></p>
<p>可以从表中得出，只有在opcode[15:13]为111且[12:11]不为00时，才对应32位</p>
<h2 id="Android平台基于异常hook的实现流程"><a href="#Android平台基于异常hook的实现流程" class="headerlink" title="Android平台基于异常hook的实现流程"></a>Android平台基于异常hook的实现流程</h2><p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221108190001784.png" alt="image-20221108190001784"></p>
<p>注意的点主要是两个</p>
<ul>
<li>注册异常处理函数，对目标地址写入异常指令</li>
<li>执行完后将目标地址恢复，在地址后设置异常，然后下一个异常将原指令地址设置为异常</li>
</ul>
<h3 id="基于异常hook的实现代码"><a href="#基于异常hook的实现代码" class="headerlink" title="基于异常hook的实现代码"></a>基于异常hook的实现代码</h3><p>代码自己看，逻辑主要就是DoExceptionHook中将sigaction结构体数据赋值对应的异常和自己写的异常处理函数，再传入sigaction函数之中。然后就和上面的差不多了。</p>
<h3 id="Android平台的Inline-Hook实现"><a href="#Android平台的Inline-Hook实现" class="headerlink" title="Android平台的Inline Hook实现"></a>Android平台的Inline Hook实现</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>改汇编跳到其他位置执行自己的代码和原汇编指令后跳回来</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221110110628461.png" alt="image-20221110110628461"></p>
<p>注意此处第③步执行原指令2的时候，如果指令2是相对寻址的指令，要进行指令修复</p>
<h3 id="Android平台导入表hook的实现"><a href="#Android平台导入表hook的实现" class="headerlink" title="Android平台导入表hook的实现"></a>Android平台导入表hook的实现</h3><p>和windows下的IAT Hook相似，原理就是替换要hook的导入函数地址，然后导入函数调用的时候首先获得执行时机</p>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>假设模块TargetLibrary模块内部调用了gettimeofday函数 ，我们想要hook该函数修改某些信息。</p>
<p>打开so文件并解析elf文件格式。先找到静态的got表的位置，读取gettimeofday的函数地址，然后在got表里面寻找对应的函数，看那个函数的入口地址是gettimeofday。遍历一圈，如果遍历到的名字相匹配，就将该函数的地址替换为新的函数地址。</p>
<p>注意的点如下</p>
<ul>
<li>可以在&#x2F;proc&#x2F;[pid]&#x2F;maps找到对应so文件的绝对路径和so文件的基址</li>
<li>需要将对应需要改写的函数地址的页改为可写的权限</li>
</ul>
<h4 id="导入表hook实现流程"><a href="#导入表hook实现流程" class="headerlink" title="导入表hook实现流程"></a>导入表hook实现流程</h4><p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221110144529916.png" alt="image-20221110144529916"></p>
<h1 id="第十六章-游戏进程的模块信息获取"><a href="#第十六章-游戏进程的模块信息获取" class="headerlink" title="第十六章 游戏进程的模块信息获取"></a>第十六章 游戏进程的模块信息获取</h1><h2 id="游戏内容读写方式分类"><a href="#游戏内容读写方式分类" class="headerlink" title="游戏内容读写方式分类"></a>游戏内容读写方式分类</h2><p>可以分为两大类</p>
<ul>
<li>注入式：注入游戏进程空间，比如ptrace，Zygote式注入</li>
<li>非注入式：通过安卓系统读写游戏内容，不需要注入游戏空间</li>
</ul>
<h3 id="非注入式篡改"><a href="#非注入式篡改" class="headerlink" title="非注入式篡改"></a>非注入式篡改</h3><p>主流的非注入实现方式有三类</p>
<ul>
<li>修改APK安装包</li>
<li>修改Android系统data目录下的文件</li>
<li>修改proc文件夹相关信息</li>
</ul>
<h4 id="篡改apk安装包"><a href="#篡改apk安装包" class="headerlink" title="篡改apk安装包"></a>篡改apk安装包</h4><p>常用修改方式</p>
<ul>
<li>改跳转为nop</li>
<li>修改寄存器 在函数头，只需要修改一个byte就可以实现。改变寄存器，让本来减去的很小的值变成另一个寄存器的很大的值，从而实现秒杀</li>
<li>抹除明文字符串  这些字符串想key-value的形式，如果抹去key字符串的话，如果验证不严谨，可能导致出现默认值或错乱值，导致外挂功能实现</li>
</ul>
<h3 id="注入式篡改"><a href="#注入式篡改" class="headerlink" title="注入式篡改"></a>注入式篡改</h3><p>目的性比较强，首先先静态分析so文件，找到要修改的部分，然后动态运行途中注入，通过改变读写权限然后修改或hook的形式来对程序进行篡改</p>
<p>需要一定代码开发能力和逆向分析能力</p>
<h4 id="篡改数据"><a href="#篡改数据" class="headerlink" title="篡改数据"></a>篡改数据</h4><p>两种方法</p>
<ul>
<li>通过汇编指令修改，比如STR指令可以直接对内存数据进行修改</li>
<li>通过API修改，比如memcpy，memset等</li>
</ul>
<h4 id="篡改逻辑代码"><a href="#篡改逻辑代码" class="headerlink" title="篡改逻辑代码"></a>篡改逻辑代码</h4><p>有两种方式</p>
<ul>
<li>暴力篡改，这种是注入式里面最简单的，用一个mprotect改变权限，然后嗯修改就完事了</li>
<li>hook篡改</li>
</ul>
<p>其中hook篡改一般也分为两种，一种是函数地址的hook，比如hook导入表和虚表。还有一种是汇编语言的hook，比如异常hook，inline hook。</p>
<ul>
<li>函数地址的hook，操作较为简单，但是缺点是只能获得返回值和参数，局限性比较强</li>
<li>汇编语言的hook，虽然比较麻烦，但是优点很明显，可以获得函数执行过程的参数和寄存器数据</li>
</ul>
<h1 id="第十七章-反调试技术"><a href="#第十七章-反调试技术" class="headerlink" title="第十七章 反调试技术"></a>第十七章 反调试技术</h1><h2 id="安卓平台常规反调试"><a href="#安卓平台常规反调试" class="headerlink" title="安卓平台常规反调试"></a>安卓平台常规反调试</h2><h3 id="self-Debugging反调试"><a href="#self-Debugging反调试" class="headerlink" title="self-Debugging反调试"></a>self-Debugging反调试</h3><p>指父进程创建一个子进程，并由这个子进程调试父进程的技术，ctf也遇到过几次了，就是双进程保护</p>
<ul>
<li>消耗的系统资源比较少</li>
<li>几乎不影响保护进程的性能</li>
<li>轻易的阻止其他进程调试受保护的进程</li>
</ul>
<p>方案很简单，实现起来很麻烦。此种反调试的基石是ptrace</p>
<p>介绍被调试进程的状态：一个被调试进程只有两种状态，一个是运行一个是暂停。运行好理解，暂停比较麻烦。</p>
<p>有四种暂停的状态：signal-delivery-stop,group-stop,syscall-stop,ptrace-event-stop</p>
<h4 id="signal-delivery-stop"><a href="#signal-delivery-stop" class="headerlink" title="signal-delivery-stop"></a>signal-delivery-stop</h4><p>当一个进程收到除了SIGKILL之外的信号的时候，内核会选择该进程任意一个线程来处理这个信号，如果当前线程处于被调试的状态，该线程就会处于signal-delivery-stop的状态，然后调试器通过Waitpid来等待该事件并收到信号。此时调试器来处理该信号，此时进程没有真正的收到信号。它可以让该信号被丢弃，让进程永远无法收到信号。</p>
<h4 id="group-stop"><a href="#group-stop" class="headerlink" title="group-stop"></a>group-stop</h4><p>出现于多线程的情况。如果调试器a调试进程b，而调试器a的进程崩溃了。但是进程b还在调试中，就会处于group-stop的状态，只有给进程b SIGCONT的信号才会让他继续进行，可是这种情况的发生对self debugging是很不利的</p>
<p>被调试进程处于group-stop的状态必须满足两种条件</p>
<ul>
<li>被调试进程处于被调试状态</li>
<li>收到暂停信号</li>
</ul>
<p>调试器可以通过避免被调试的进程收到暂停信号来阻止这种情况发生。</p>
<p>总共有四种信号</p>
<p>SIGSTOP  SIGTSTP  SIGTTIN  SIGTTOU</p>
<p>会导致进程陷入group-stop状态</p>
<h4 id="反调试方案的实现过程"><a href="#反调试方案的实现过程" class="headerlink" title="反调试方案的实现过程"></a>反调试方案的实现过程</h4><p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221111165606465.png" alt="image-20221111165606465"></p>
<h4 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h4><p>因为父进程fork出一个子进程作为调试器来调试主进程嘛，我们直接ida attach子进程，然后间接调试父进程即可。</p>
<h3 id="轮询检测反调试方案"><a href="#轮询检测反调试方案" class="headerlink" title="轮询检测反调试方案"></a>轮询检测反调试方案</h3><h4 id="轮询的原理"><a href="#轮询的原理" class="headerlink" title="轮询的原理"></a>轮询的原理</h4><p>通过读取&#x2F;proc&#x2F;pid&#x2F;status文件，判断当前进程有无在被调试器调试。</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221111171436139.png" alt="image-20221111171436139"></p>
<p>各个字段的解释如下</p>
<p>name：进程名</p>
<p>State：状态</p>
<p>Tgid：线程组的id，一般只进程名</p>
<p>Pid：线程的id，和getpid函数返回值一样</p>
<p>PPid：父进程的进程id</p>
<p>TracerPid：实现调试功能的进程ID，如果值为0代表未被调试</p>
<p>此种方法消耗资源较大，因为它会一直查询对应的TracerPid。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>就是看TracerPid</p>
<h3 id="java层的反调试"><a href="#java层的反调试" class="headerlink" title="java层的反调试"></a>java层的反调试</h3><p>主要针对基于JDWP协议的Java代码调试器</p>
<p>安卓系统中，要想用JDWP来调试Java代码，需要在AndroidManifest.xml里面将android：debugger的属性改为true</p>
<p>所以实现的话，就判断这个属性是否为true咯，Android SDK中的android.os.Debug类里面提供了一个isDebuggerConnected的方法，就是用于判断这个</p>
<h1 id="第十八章-游戏逆向分析实战篇"><a href="#第十八章-游戏逆向分析实战篇" class="headerlink" title="第十八章 游戏逆向分析实战篇"></a>第十八章 游戏逆向分析实战篇</h1><h2 id="c-游戏分析实战"><a href="#c-游戏分析实战" class="headerlink" title="c++游戏分析实战"></a>c++游戏分析实战</h2><h3 id="c-游戏识别"><a href="#c-游戏识别" class="headerlink" title="c++游戏识别"></a>c++游戏识别</h3><p>Cocos2d-x是一个移动游戏开发框架，可以单独用c++或lua进行开发，也可以混合使用</p>
<h3 id="c-基础"><a href="#c-基础" class="headerlink" title="c++基础"></a>c++基础</h3><h4 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h4><p>如果一个类有虚函数，那么在它的内存结构中，头部首先会有一个指针，这个指针叫做虚表指针，指向的位置是一个函数指针数组，就叫做虚表，也就是一连串的函数地址。这个数组每一个元素都是这个类的虚函数的地址。同一个类的所有对象共享一个虚表。如果两个类的虚函数不同，会有两个虚表</p>
<h3 id="逆向方法"><a href="#逆向方法" class="headerlink" title="逆向方法"></a>逆向方法</h3><h4 id="看字符串"><a href="#看字符串" class="headerlink" title="看字符串"></a>看字符串</h4><p>shift+f12</p>
<h4 id="send函数回溯"><a href="#send函数回溯" class="headerlink" title="send函数回溯"></a>send函数回溯</h4><p>游戏总会进行网络通讯，而Android的最底层的通信的函数是send，而如果直接看send的数据是看不到啥的，因为一般都会把数据进行加密。所以我们只需要查找每个用到send的地方，然后交叉引用往回回溯，找到对应的加密函数或者组包函数就行。组包函数的上层一般是功能函数，在组包函数中修改可以改变游戏与服务器通讯的底层通信逻辑</p>
<p>过程可以借助ida脚本，过滤一些用的多的函数，比如心跳函数，也可以输出log</p>
<h4 id="输出log"><a href="#输出log" class="headerlink" title="输出log"></a>输出log</h4><p>在一些被频繁调用或者有明文信息的函数处，如果有必要，也可以输出log进行分析，方式可以是ida脚本也可以是注入进程并设置hook的方式</p>
<h3 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h3><p>相对较简单，注入然后hook，篡改游戏逻辑</p>
<ul>
<li>hook关键函数，修改传入参数，比如如果有SetHp函数，直接传进去一个114514，让你成为臭血牛</li>
<li>hook关键函数，修改返回值。比如如果存在一个计算伤害的函数，直接改变返回值，实现一刀9999</li>
<li>hook关键函数，实现多次调用。比如hit函数调用114514次，直接臭死对手</li>
<li>hook关键函数，直接返回。比如dead</li>
<li>直接修改逻辑。通过注入或者远程ptrace后，直接修改判断代码，嗯改</li>
</ul>
<h2 id="Unity-3D游戏分析实战"><a href="#Unity-3D游戏分析实战" class="headerlink" title="Unity 3D游戏分析实战"></a>Unity 3D游戏分析实战</h2><h3 id="Unity3D-破解方法"><a href="#Unity3D-破解方法" class="headerlink" title="Unity3D 破解方法"></a>Unity3D 破解方法</h3><ul>
<li>修改Unity运行时编译生成的汇编代码<ul>
<li>修改传入的参数，寄存器，一般为set函数</li>
<li>在汇编代码中尽量不修改内存和opcode，尽量修改寄存器</li>
</ul>
</li>
<li>反编译Assenbly-CSharp.dll，直接修改源代码<ul>
<li>修改函数的返回值</li>
<li>直接删除函数体，留下ret指令</li>
<li>对应的函数中添加新的函数调用，主动进行调用</li>
</ul>
</li>
<li>逆向分析Assenbly-CSharp.dll，修改IL指令</li>
<li>在加载dll文件函数的位置动态保存原始的dll代码，可以绕过dll加密，并修改源代码<ul>
<li>Hook mono_image_open_from_data_full函数动态保存dll文件。通过ida和jeb动态挂起进程，然后在mono_image_open_from_data_full函数位置设置断点，执行到断点处的时候动态保存即可</li>
</ul>
</li>
</ul>
<p>如果可以在函数头下断点，就用改变寄存器的方法进行测试，如果不行就用第二种方法。把修改后的Assenblyxxx文件注入游戏中，让游戏执行修改后的代码</p>
<h3 id="分析涉及的工具"><a href="#分析涉及的工具" class="headerlink" title="分析涉及的工具"></a>分析涉及的工具</h3><p>对Unity3D的分析实际上就是对源码层的分析</p>
<h4 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h4><p>不用多说</p>
<h4 id="ILSpy"><a href="#ILSpy" class="headerlink" title="ILSpy"></a>ILSpy</h4><p>反编译和分析dll代码，也可以以源码形式保存反编译的代码</p>
<h4 id="NET-Reflector和Reflexil工具"><a href="#NET-Reflector和Reflexil工具" class="headerlink" title=".NET Reflector和Reflexil工具"></a>.NET Reflector和Reflexil工具</h4><p>.NET Reflector也可以反编译和分析dll代码，也弥补了ILspy的功能性缺陷，可以分析出错误的CLR文件头。一些在ILSpy中不能加载的dll文件，如果只是改了文件头这些，可以放到relfector里面分析。</p>
<h4 id="ildasm和ilasm工具"><a href="#ildasm和ilasm工具" class="headerlink" title="ildasm和ilasm工具"></a>ildasm和ilasm工具</h4><p>ildasm可以反编译dll文件，动态保存反编译后的IL指令，ilasm则可以用命令ilasm &#x2F;dll *.il重打包IL码，二者可以用于静态修改c#代码的中间层IL指令</p>
<ul>
<li>nop的机器码 0x00</li>
<li>ldc.i4.0  0x16</li>
<li>ldc.i4.1 0x17</li>
<li>ret        0x2a</li>
<li>ldc.r4    0x22，后面为四个字节数据</li>
</ul>
<h2 id="lua游戏分析实战"><a href="#lua游戏分析实战" class="headerlink" title="lua游戏分析实战"></a>lua游戏分析实战</h2><p>关键点是获取lua代码，和Unity3D类似是源码层的逆向分析</p>
<h3 id="识别lua游戏"><a href="#识别lua游戏" class="headerlink" title="识别lua游戏"></a>识别lua游戏</h3><p>去Android解压后的lib目录下找so文件，看里面有没有lua的模块例如libcocos2dlua，libhellolua等。一般最大的so模块可能内置了。</p>
<p>也可以关注已解压的assets目录下是否有脚本信息。一般会加密，不过有的厂商也不会。</p>
<h3 id="破解方法-1"><a href="#破解方法-1" class="headerlink" title="破解方法"></a>破解方法</h3><p>主要分为两步：</p>
<ul>
<li>获取游戏的lua脚本</li>
<li>替换</li>
</ul>
<p>不同安全级别的手游，获取lua脚本的时机也不一样（本质是研制lua引擎加载lua脚本的整条加载链，不断分析并找到合适的时机点，然后动态保存和替换</p>
<h4 id="asset资源中可获取lua脚本"><a href="#asset资源中可获取lua脚本" class="headerlink" title="asset资源中可获取lua脚本"></a>asset资源中可获取lua脚本</h4><p>在asset目录下获得lua或者luac源码</p>
<p>针对有lua源码的类型，直接APKtool重打包</p>
<p>针对有Luac源码的类型，可以用Unluac开源工具将其反编译为lua源码，然后修改并替换修改后的Lua源码文件（Luac是lua的字节码文件）</p>
<h4 id="在luaL-loadbuffer函数处提取"><a href="#在luaL-loadbuffer函数处提取" class="headerlink" title="在luaL_loadbuffer函数处提取"></a>在luaL_loadbuffer函数处提取</h4><p>这个是一个被频繁调用的加载点，Cocos2d-x引起的Lua加载器为cocos2dx_lua_loader，最终都是调用luaL_loadbuffer加载</p>
<p>一般而言，厂商会在该函数上方解密lua文件，然后传入这个函数的参数就是解密后的数据。我们只需要在调用该函数的地方前下断点，然后就能提取出解密后的文件了</p>
<p><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20221112142200569.png" alt="image-20221112142200569"></p>
<h4 id="在底层的reader函数处获取"><a href="#在底层的reader函数处获取" class="headerlink" title="在底层的reader函数处获取"></a>在底层的reader函数处获取</h4><p>lua引擎加载Lua脚本的底层是lua_reader函数。负责底层的脚本遍历，因此在此处动态保存的脚本是lua明文脚本，所有加密都没了（除非改了lua opcode或者引擎逻辑）（感觉可以出题）</p>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="ida-1"><a href="#ida-1" class="headerlink" title="ida"></a>ida</h4><h4 id="ChunkSpy"><a href="#ChunkSpy" class="headerlink" title="ChunkSpy"></a>ChunkSpy</h4><p>解析luac的文件结构，方便阅读</p>
<h4 id="Unluac"><a href="#Unluac" class="headerlink" title="Unluac"></a>Unluac</h4><p>Lua反编译开源项目，可以把luac反编译为lua代码</p>
<h1 id="第二十章-外挂开发实战-《2048》手游快速通关"><a href="#第二十章-外挂开发实战-《2048》手游快速通关" class="headerlink" title="第二十章 外挂开发实战-《2048》手游快速通关"></a>第二十章 外挂开发实战-《2048》手游快速通关</h1><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>java代码一般只用于界面显示，如果没有lib的话证明这个游戏是很简单的游戏，逻辑不复杂。</p>
<p>具体逆向过程看书吧，这里直接得出结论，addBoxAtIndexWithLevel函数传入的第二个参数n是数值的2的n次方</p>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>有几种思路</p>
<ul>
<li>用inline hook的方式。用Cydia Substrate组件libsubstrate.so模块的MSHookFunction函数对addBoxAtIndexWithLevel进行hook的操作，将传入的第二个参数改变即可实现外挂功能</li>
<li>导入表hook 对导入函数arc4random(2048的随机数值的函数)进行hook，利用_Unwind_Backtrace, _Unwind_GetIP,dladdr函数得到调用者的信息，如果是addBoxAtIndex调用，就将返回值设置为0.这样就可以每次生成数值为2的box</li>
<li>用异常hook和导入表hook的方式，和第二种差不多，在addBoxAtIndex中的arc4random调用之前设置异常hook并计数，然后对arc4random函数设置导入表hook，监控replace_arc4random的运行次数，然后把返回值都设置为0，就能和第二种一样</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xiananren.github.io">Xman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xiananren.github.io/2023/02/20/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E6%89%8B%E6%B8%B8%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">https://xiananren.github.io/2023/02/20/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E6%89%8B%E6%B8%B8%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiananren.github.io" target="_blank">Xman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/63f38dacf144a01007224a7f.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/02/21/%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/" title="MAS CRACKME3 分析笔记"><img class="cover" src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230221122709333.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MAS CRACKME3 分析笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/63f38a68f144a010071d33b2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xman</div><div class="author-info__description">深大信安Aurora/国际战队r3kapig逆向手，擅长坐牢</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">live a life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">静态修改文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">静态修改游戏资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">静态修改游戏代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.3.</span> <span class="toc-text">修改配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%AF%A1%E6%94%B9%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.</span> <span class="toc-text">动态篡改逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">修改数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.</span> <span class="toc-text">游戏协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%91%E6%B8%B8%E6%88%8F%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">重发游戏协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A4%96%E6%8C%82%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%88%86%E7%B1%BB%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二章 外挂的定义，分类和实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E6%8C%82%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">外挂分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%89%88%E5%A4%96%E6%8C%82"><span class="toc-number">2.1.1.</span> <span class="toc-text">辅助版外挂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">内存修改器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%80%9F%E5%99%A8"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">变速器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">按键精灵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">模拟器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">抓包工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E8%A7%A3%E7%89%88%E5%A4%96%E6%8C%82"><span class="toc-number">2.1.2.</span> <span class="toc-text">破解版外挂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%89%88%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">辅助版外挂实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">专用插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">通用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%E5%99%A8-1"><span class="toc-number">2.1.3.2.1.</span> <span class="toc-text">内存修改器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%80%9F%E5%99%A8-1"><span class="toc-number">2.1.3.2.2.</span> <span class="toc-text">变速器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5-1"><span class="toc-number">2.1.3.2.3.</span> <span class="toc-text">按键精灵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8-1"><span class="toc-number">2.1.3.2.4.</span> <span class="toc-text">模拟器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7-1"><span class="toc-number">2.1.3.2.5.</span> <span class="toc-text">抓包工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E8%A7%A3%E7%89%88%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.4.</span> <span class="toc-text">破解版外挂实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">逻辑代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%B5%84%E6%BA%90"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">数据资源</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%89%8B%E6%B8%B8%E5%A4%96%E6%8C%82%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB"><span class="toc-number">3.</span> <span class="toc-text">第三章 手游外挂技术汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#arm%E6%B1%87%E7%BC%96"><span class="toc-number">3.1.</span> <span class="toc-text">arm汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-x2F-c"><span class="toc-number">3.2.</span> <span class="toc-text">c&#x2F;c++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E5%BC%80%E5%8F%91"><span class="toc-number">3.3.</span> <span class="toc-text">Android开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOS%E5%BC%80%E5%8F%91"><span class="toc-number">3.4.</span> <span class="toc-text">IOS开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E"><span class="toc-number">3.5.</span> <span class="toc-text">常用的游戏引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9"><span class="toc-number">3.6.</span> <span class="toc-text">静态修改</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%89%8B%E6%B8%B8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">第七章 手游开发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">游戏玩法与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MMORPG"><span class="toc-number">4.1.1.</span> <span class="toc-text">MMORPG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FPS"><span class="toc-number">4.1.2.</span> <span class="toc-text">FPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARPG"><span class="toc-number">4.1.3.</span> <span class="toc-text">ARPG</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E6%B8%B8%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80"><span class="toc-number">4.2.</span> <span class="toc-text">手游开发语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E6%B8%B8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">手游网络模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.</span> <span class="toc-text">第八章 游戏引擎的基本概念和常见介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.1.</span> <span class="toc-text">游戏引擎是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.2.</span> <span class="toc-text">游戏引擎子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.2.1.</span> <span class="toc-text">渲染系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">音频系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.2.3.</span> <span class="toc-text">物理系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD"><span class="toc-number">5.2.4.</span> <span class="toc-text">人工智能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%B8%B8%E6%88%8F%E6%BC%8F%E6%B4%9E%E7%AE%80%E8%BF%B0"><span class="toc-number">6.</span> <span class="toc-text">第九章 游戏漏洞简述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E"><span class="toc-number">6.1.1.</span> <span class="toc-text">游戏逻辑漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%8D%8F%E8%AE%AE%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%BC%8F%E6%B4%9E"><span class="toc-number">6.1.2.</span> <span class="toc-text">游戏协议稳定性漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A0%A1%E9%AA%8C%E7%96%8F%E5%BF%BD%E5%9E%8B%E6%BC%8F%E6%B4%9E"><span class="toc-number">6.1.3.</span> <span class="toc-text">游戏服务端校验疏忽型漏洞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">第十章 静态分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#arm%E9%80%9F%E6%88%90"><span class="toc-number">7.1.</span> <span class="toc-text">arm速成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">体系简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%B7%E4%BE%8B"><span class="toc-number">7.1.2.</span> <span class="toc-text">指令样例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-x2F-BL%E6%8C%87%E4%BB%A4"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">B&#x2F;BL指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#offset"><span class="toc-number">7.1.2.1.1.</span> <span class="toc-text">offset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#L"><span class="toc-number">7.1.2.1.2.</span> <span class="toc-text">L</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%A0%81"><span class="toc-number">7.1.2.1.3.</span> <span class="toc-text">标识码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cond"><span class="toc-number">7.1.2.1.4.</span> <span class="toc-text">cond</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LDR-x2F-STR"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">LDR&#x2F;STR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Cond"><span class="toc-number">7.1.2.2.1.</span> <span class="toc-text">Cond</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#op"><span class="toc-number">7.1.2.2.2.</span> <span class="toc-text">op</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#I"><span class="toc-number">7.1.2.2.3.</span> <span class="toc-text">I</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B"><span class="toc-number">7.1.2.2.4.</span> <span class="toc-text">B</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#L-1"><span class="toc-number">7.1.2.2.5.</span> <span class="toc-text">L</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Rn"><span class="toc-number">7.1.2.2.6.</span> <span class="toc-text">Rn</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Rd"><span class="toc-number">7.1.2.2.7.</span> <span class="toc-text">Rd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Offset"><span class="toc-number">7.1.2.2.8.</span> <span class="toc-text">Offset</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thumb%E6%8C%87%E4%BB%A4%E7%AE%80%E8%BF%B0"><span class="toc-number">7.1.3.</span> <span class="toc-text">Thumb指令简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">7.1.4.</span> <span class="toc-text">函数传参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">第十一章 动态调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AE%89%E5%8D%93%E5%8E%9F%E7%94%9F%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">8.1.</span> <span class="toc-text">加载安卓原生动态链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95JNI-Onload%E5%92%8Cinit-array"><span class="toc-number">8.1.1.</span> <span class="toc-text">调试JNI_Onload和init_array</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">第十三章 注入技术的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E4%B8%8Bptrace%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.1.</span> <span class="toc-text">Android下ptrace注入技术的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ptrace%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.1.</span> <span class="toc-text">ptrace函数介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#request"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pid"><span class="toc-number">9.1.1.2.</span> <span class="toc-text">pid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addr-x2F-data"><span class="toc-number">9.1.1.3.</span> <span class="toc-text">addr&#x2F;data</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptrace%E6%B3%A8%E5%85%A5%E8%BF%9B%E7%A8%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">9.1.2.</span> <span class="toc-text">ptrace注入进程流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">9.1.2.1.</span> <span class="toc-text">整体流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptrace%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.1.3.</span> <span class="toc-text">ptrace注入的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">附加到远程进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">读取和写入寄存器值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">9.1.3.3.</span> <span class="toc-text">远程进程的内存读取和写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.3.4.</span> <span class="toc-text">远程调用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC"><span class="toc-number">9.1.3.5.</span> <span class="toc-text">恢复寄存器值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detach%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.1.3.6.</span> <span class="toc-text">detach进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E4%B8%8BZygote%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.</span> <span class="toc-text">Android下Zygote注入技术的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.1.</span> <span class="toc-text">注入原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">9.2.2.</span> <span class="toc-text">注入实现流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.3.</span> <span class="toc-text">注入器的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E5%99%A8%E5%90%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.4.</span> <span class="toc-text">注入器各功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%ADSeLinux"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">关闭SeLinux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%88%B0Zygote%EF%BC%8C%E4%BF%9D%E5%AD%98%E8%BF%9B%E7%A8%8B%E7%8E%B0%E5%9C%BA"><span class="toc-number">9.2.4.2.</span> <span class="toc-text">附加到Zygote，保存进程现场</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Zygote%E8%BF%9B%E7%A8%8B%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">9.2.4.3.</span> <span class="toc-text">获取Zygote进程关键函数的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8mmap%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.4.4.</span> <span class="toc-text">调用mmap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEshellcode"><span class="toc-number">9.2.4.5.</span> <span class="toc-text">配置shellcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8shellcode"><span class="toc-number">9.2.4.6.</span> <span class="toc-text">远程调用shellcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8munmap%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">9.2.4.7.</span> <span class="toc-text">调用munmap释放内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E8%BF%9B%E7%A8%8B%E5%88%B0%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="toc-number">9.2.4.8.</span> <span class="toc-text">恢复进程到初始状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5Zygote%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">9.2.5.</span> <span class="toc-text">注入Zygote模块的功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E6%84%9F%E6%9F%93elf%E6%96%87%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.</span> <span class="toc-text">Android感染elf文件的注入技术实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E6%9F%93elf%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">9.3.1.</span> <span class="toc-text">感染elf文件实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E6%9F%93elf%E6%96%87%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">9.3.2.</span> <span class="toc-text">感染elf文件的注入实现过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E6%9F%93elf%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">9.3.3.</span> <span class="toc-text">感染elf文件的实例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">9.3.4.</span> <span class="toc-text">代码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-hook%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">第十四章 hook技术的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">10.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E7%9A%84hook%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.2.</span> <span class="toc-text">基于异常的hook实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8hook%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">10.3.</span> <span class="toc-text">Android平台基于异常hook的实现流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8hook%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">10.3.1.</span> <span class="toc-text">基于异常hook的实现代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E5%B9%B3%E5%8F%B0%E7%9A%84Inline-Hook%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.3.2.</span> <span class="toc-text">Android平台的Inline Hook实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E5%B9%B3%E5%8F%B0%E5%AF%BC%E5%85%A5%E8%A1%A8hook%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.3.3.</span> <span class="toc-text">Android平台导入表hook的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">10.3.3.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8hook%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">10.3.3.2.</span> <span class="toc-text">导入表hook实现流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%B8%B8%E6%88%8F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96"><span class="toc-number">11.</span> <span class="toc-text">第十六章 游戏进程的模块信息获取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%86%85%E5%AE%B9%E8%AF%BB%E5%86%99%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">游戏内容读写方式分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%B3%A8%E5%85%A5%E5%BC%8F%E7%AF%A1%E6%94%B9"><span class="toc-number">11.1.1.</span> <span class="toc-text">非注入式篡改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AF%A1%E6%94%B9apk%E5%AE%89%E8%A3%85%E5%8C%85"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">篡改apk安装包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E5%BC%8F%E7%AF%A1%E6%94%B9"><span class="toc-number">11.1.2.</span> <span class="toc-text">注入式篡改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AF%A1%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">11.1.2.1.</span> <span class="toc-text">篡改数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AF%A1%E6%94%B9%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81"><span class="toc-number">11.1.2.2.</span> <span class="toc-text">篡改逻辑代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">12.</span> <span class="toc-text">第十七章 反调试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E5%B9%B3%E5%8F%B0%E5%B8%B8%E8%A7%84%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">12.1.</span> <span class="toc-text">安卓平台常规反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#self-Debugging%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">12.1.1.</span> <span class="toc-text">self-Debugging反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#signal-delivery-stop"><span class="toc-number">12.1.1.1.</span> <span class="toc-text">signal-delivery-stop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-stop"><span class="toc-number">12.1.1.2.</span> <span class="toc-text">group-stop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">12.1.1.3.</span> <span class="toc-text">反调试方案的实现过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.1.4.</span> <span class="toc-text">破解方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%A3%80%E6%B5%8B%E5%8F%8D%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88"><span class="toc-number">12.1.2.</span> <span class="toc-text">轮询检测反调试方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.2.1.</span> <span class="toc-text">轮询的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.1.2.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%B1%82%E7%9A%84%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">12.1.3.</span> <span class="toc-text">java层的反调试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-number">13.</span> <span class="toc-text">第十八章 游戏逆向分析实战篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98"><span class="toc-number">13.1.</span> <span class="toc-text">c++游戏分析实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%B8%B8%E6%88%8F%E8%AF%86%E5%88%AB"><span class="toc-number">13.1.1.</span> <span class="toc-text">c++游戏识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%9F%BA%E7%A1%80"><span class="toc-number">13.1.2.</span> <span class="toc-text">c++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E8%A1%A8"><span class="toc-number">13.1.2.1.</span> <span class="toc-text">虚表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95"><span class="toc-number">13.1.3.</span> <span class="toc-text">逆向方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.1.3.1.</span> <span class="toc-text">看字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#send%E5%87%BD%E6%95%B0%E5%9B%9E%E6%BA%AF"><span class="toc-number">13.1.3.2.</span> <span class="toc-text">send函数回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BAlog"><span class="toc-number">13.1.3.3.</span> <span class="toc-text">输出log</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E8%A7%A3%E6%80%9D%E8%B7%AF"><span class="toc-number">13.1.4.</span> <span class="toc-text">破解思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-3D%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98"><span class="toc-number">13.2.</span> <span class="toc-text">Unity 3D游戏分析实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity3D-%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.1.</span> <span class="toc-text">Unity3D 破解方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%B6%89%E5%8F%8A%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">13.2.2.</span> <span class="toc-text">分析涉及的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ida"><span class="toc-number">13.2.2.1.</span> <span class="toc-text">ida</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ILSpy"><span class="toc-number">13.2.2.2.</span> <span class="toc-text">ILSpy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NET-Reflector%E5%92%8CReflexil%E5%B7%A5%E5%85%B7"><span class="toc-number">13.2.2.3.</span> <span class="toc-text">.NET Reflector和Reflexil工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ildasm%E5%92%8Cilasm%E5%B7%A5%E5%85%B7"><span class="toc-number">13.2.2.4.</span> <span class="toc-text">ildasm和ilasm工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98"><span class="toc-number">13.3.</span> <span class="toc-text">lua游戏分析实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%ABlua%E6%B8%B8%E6%88%8F"><span class="toc-number">13.3.1.</span> <span class="toc-text">识别lua游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95-1"><span class="toc-number">13.3.2.</span> <span class="toc-text">破解方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#asset%E8%B5%84%E6%BA%90%E4%B8%AD%E5%8F%AF%E8%8E%B7%E5%8F%96lua%E8%84%9A%E6%9C%AC"><span class="toc-number">13.3.2.1.</span> <span class="toc-text">asset资源中可获取lua脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8luaL-loadbuffer%E5%87%BD%E6%95%B0%E5%A4%84%E6%8F%90%E5%8F%96"><span class="toc-number">13.3.2.2.</span> <span class="toc-text">在luaL_loadbuffer函数处提取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84reader%E5%87%BD%E6%95%B0%E5%A4%84%E8%8E%B7%E5%8F%96"><span class="toc-number">13.3.2.3.</span> <span class="toc-text">在底层的reader函数处获取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">13.3.3.</span> <span class="toc-text">常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ida-1"><span class="toc-number">13.3.3.1.</span> <span class="toc-text">ida</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChunkSpy"><span class="toc-number">13.3.3.2.</span> <span class="toc-text">ChunkSpy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unluac"><span class="toc-number">13.3.3.3.</span> <span class="toc-text">Unluac</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E5%A4%96%E6%8C%82%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-%E3%80%8A2048%E3%80%8B%E6%89%8B%E6%B8%B8%E5%BF%AB%E9%80%9F%E9%80%9A%E5%85%B3"><span class="toc-number">14.</span> <span class="toc-text">第二十章 外挂开发实战-《2048》手游快速通关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%88%86%E6%9E%90"><span class="toc-number">14.1.</span> <span class="toc-text">逆向分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.2.</span> <span class="toc-text">功能实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/sofixer%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/" title="Sofixer源码分析"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230221122709333.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Sofixer源码分析"/></a><div class="content"><a class="title" href="/2023/09/01/sofixer%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/" title="Sofixer源码分析">Sofixer源码分析</a><time datetime="2023-09-01T08:18:00.670Z" title="发表于 2023-09-01 16:18:00">2023-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/30/miasm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="miasm学习笔记"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230707141826519.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="miasm学习笔记"/></a><div class="content"><a class="title" href="/2023/08/30/miasm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="miasm学习笔记">miasm学习笔记</a><time datetime="2023-08-30T08:05:44.543Z" title="发表于 2023-08-30 16:05:44">2023-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/19/2023%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/" title="2023腾讯游戏安全比赛总结"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230419004935148.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023腾讯游戏安全比赛总结"/></a><div class="content"><a class="title" href="/2023/04/19/2023%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/" title="2023腾讯游戏安全比赛总结">2023腾讯游戏安全比赛总结</a><time datetime="2023-04-18T16:26:05.746Z" title="发表于 2023-04-19 00:26:05">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/07/%E3%80%8A%E5%9B%BE%E8%A7%A3http%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="图解http-阅读笔记"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230307171802380.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解http-阅读笔记"/></a><div class="content"><a class="title" href="/2023/03/07/%E3%80%8A%E5%9B%BE%E8%A7%A3http%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="图解http-阅读笔记">图解http-阅读笔记</a><time datetime="2023-03-07T08:01:10.045Z" title="发表于 2023-03-07 16:01:10">2023-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/05/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="中科大计算机网络学习笔记"><img src="https://xiananren-1308648057.cos.ap-guangzhou.myqcloud.com/image-20230305205457810.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="中科大计算机网络学习笔记"/></a><div class="content"><a class="title" href="/2023/03/05/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="中科大计算机网络学习笔记">中科大计算机网络学习笔记</a><time datetime="2023-03-05T12:54:23.472Z" title="发表于 2023-03-05 20:54:23">2023-03-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xman</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>